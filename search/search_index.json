{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>The Compose Rules is a set of custom Ktlint / Detekt rules to ensure that your composables don't fall into common pitfalls, that might be easy to miss in code reviews.</p>"},{"location":"#why","title":"Why","text":"<p>It can be challenging for big teams to start adopting Compose, particularly because not everyone will start at same time or with the same patterns. We tried to ease the pain by creating a set of Compose static checks.</p> <p>Compose has lots of superpowers but also has a bunch of footguns to be aware of as seen in this Twitter Thread.</p> <p>This is where our static checks come in. We want to detect as many potential issues as we can, as quickly as we can. In this case we want an error to show prior to engineers having to review code. Similar to other static check libraries we hope this leads to a \"don't shoot the messengers\" philosphy which will foster healthy Compose adoption.</p>"},{"location":"#using-with-ktlint","title":"Using with ktlint","text":"<p>You can refer to the Using with ktlint documentation.</p>"},{"location":"#using-with-detekt","title":"Using with detekt","text":"<p>You can refer to the Using with detekt documentation.</p>"},{"location":"#migrating-from-twitter-compose-rules","title":"Migrating from Twitter Compose Rules","text":"<p>The process to migrate to these rules coming from the Twitter ones is simple.</p> <ol> <li>Change the project coordinates in your gradle build scripts<ol> <li>For detekt, <code>com.twitter.compose.rules:detekt:$version</code> becomes <code>io.nlopez.compose.rules:detekt:$version</code></li> <li>For ktlint, <code>com.twitter.compose.rules:ktlint:$version</code> becomes <code>io.nlopez.compose.rules:ktlint:$version</code></li> </ol> </li> <li>Update <code>$version</code> to the latest:  - see the project releases page.</li> <li>If you are using Detekt: update the config file (e.g. <code>detekt.yml</code>) so that the rule set name <code>TwitterCompose</code> becomes <code>Compose</code>. Keep in mind that there are a lot of new rules in this repo that weren't in Twitter's, so you'd be better copying over from the example configuration.</li> <li>Done!</li> </ol>"},{"location":"detekt/","title":"Using with detekt","text":"<p>When using the detekt Gradle Plugin, you can specify the dependency on this set of rules by using <code>detektPlugins</code>.</p> <pre><code>dependencies {\n    detektPlugins \"io.nlopez.compose.rules:detekt:&lt;VERSION&gt;\"\n}\n</code></pre>"},{"location":"detekt/#supported-versions-matrix","title":"Supported versions matrix","text":"Version Detekt version Kotlin (Syntax) 0.4.16+ 1.23.7 2.0.21 0.4.12+ 1.23.7 2.0.20 0.4.2+ 1.23.6 2.0.0 0.3.13+ 1.23.6 1.9.23 <p>Older version support can be found in the release notes.</p>"},{"location":"detekt/#using-with-detekt-cli-detekt-ide-plugin","title":"Using with detekt CLI / detekt IDE plugin","text":"<p>The releases page contains an uber jar for each version release that can be used to run with the CLI version of detekt.</p> <pre><code>detekt -p detekt-compose-&lt;VERSION&gt;-all.jar -c your/config/detekt.yml\n</code></pre> <p>For the IDE plugin, you'll need to add the uber jar to the list of custom plugins in its configuration, and don't forget to also enable the rules in the yml config provided to the plugin for it to work.</p>"},{"location":"detekt/#enabling-rules","title":"Enabling rules","text":"<p>For the rules to be picked up, you will need to enable them in your <code>detekt.yml</code> configuration file.</p> <pre><code>Compose:\n  ComposableAnnotationNaming:\n    active: true\n  ComposableNaming:\n    active: true\n    # -- You can optionally disable the checks in this rule for regex matches against the composable name (e.g. molecule presenters)\n    # allowedComposableFunctionNames: .*Presenter,.*MoleculePresenter\n  ComposableParamOrder:\n    active: true\n    # -- You can optionally have a list of types to be treated as lambdas (e.g. typedefs or fun interfaces not picked up automatically)\n    # treatAsLambda: MyLambdaType\n  CompositionLocalAllowlist:\n    active: true\n    # -- You can optionally define a list of CompositionLocals that are allowed here\n    # allowedCompositionLocals: LocalSomething,LocalSomethingElse\n  CompositionLocalNaming:\n    active: true\n  ContentEmitterReturningValues:\n    active: true\n    # -- You can optionally add your own composables here\n    # contentEmitters: MyComposable,MyOtherComposable\n  ContentTrailingLambda:\n    active: true\n    # -- You can optionally have a list of types to be treated as lambdas (e.g. typedefs or fun interfaces not picked up automatically)\n    # treatAsLambda: MyLambdaType\n    # -- You can optionally have a list of types to be treated as composable lambdas (e.g. typedefs or fun interfaces not picked up automatically).\n    # -- The difference with treatAsLambda is that those need `@Composable` MyLambdaType in the definition, while these won't.\n    # treatAsComposableLambda: MyComposableLambdaType\n  ContentSlotReused:\n      active: true\n      # -- You can optionally have a list of types to be treated as composable lambdas (e.g. typedefs or fun interfaces not picked up automatically).\n      # -- The difference with treatAsLambda is that those need `@Composable` MyLambdaType in the definition, while these won't.\n      # treatAsComposableLambda: MyComposableLambdaType\n  DefaultsVisibility:\n    active: true\n  LambdaParameterEventTrailing:\n    active: true\n    # -- You can optionally add your own composables here\n    # contentEmitters: MyComposable,MyOtherComposable\n    # -- You can add composables here that you don't want to count as content emitters (e.g. custom dialogs or modals)\n    # contentEmittersDenylist: MyNonEmitterComposable\n  LambdaParameterInRestartableEffect:\n    active: true\n    # -- You can optionally have a list of types to be treated as lambdas (e.g. typedefs or fun interfaces not picked up automatically)\n    # treatAsLambda: MyLambdaType\n  Material2:\n    active: false # Opt-in, disabled by default. Turn on if you want to disallow Material 2 usages.\n    # -- You can optionally allow parts of it, if you are in the middle of a migration.\n    # allowedFromM2: icons.Icons,TopAppBar\n  ModifierClickableOrder:\n    active: true\n    # -- You can optionally add your own Modifier types\n    # customModifiers: BananaModifier,PotatoModifier\n  ModifierComposed:\n    active: true\n    # -- You can optionally add your own Modifier types\n    # customModifiers: BananaModifier,PotatoModifier\n  ModifierMissing:\n    active: true\n    # -- You can optionally control the visibility of which composables to check for here\n    # -- Possible values are: `only_public`, `public_and_internal` and `all` (default is `only_public`)\n    # checkModifiersForVisibility: only_public\n    # -- You can optionally add your own Modifier types\n    # customModifiers: BananaModifier,PotatoModifier\n    # -- You can suppress this check in functions annotated with these annotations\n    # ignoreAnnotated: ['Potato', 'Banana']\n  ModifierNaming:\n    active: true\n    # -- You can optionally add your own Modifier types\n    # customModifiers: BananaModifier,PotatoModifier\n  ModifierNotUsedAtRoot:\n    active: true\n    # -- You can optionally add your own composables here\n    # contentEmitters: MyComposable,MyOtherComposable\n    # -- You can optionally add your own Modifier types\n    # customModifiers: BananaModifier,PotatoModifier\n  ModifierReused:\n    active: true\n    # -- You can optionally add your own Modifier types\n    # customModifiers: BananaModifier,PotatoModifier\n  ModifierWithoutDefault:\n    active: true\n  MultipleEmitters:\n    active: true\n    # -- You can optionally add your own composables here that will count as content emitters\n    # contentEmitters: MyComposable,MyOtherComposable\n    # -- You can add composables here that you don't want to count as content emitters (e.g. custom dialogs or modals)\n    # contentEmittersDenylist: MyNonEmitterComposable\n  MutableParams:\n    active: true\n  MutableStateAutoboxing:\n    active: true\n  MutableStateParam:\n    active: true\n  ParameterNaming:\n    active: true\n    # -- You can optionally have a list of types to be treated as lambdas (e.g. typedefs or fun interfaces not picked up automatically)\n    # treatAsLambda: MyLambdaType\n  PreviewAnnotationNaming:\n    active: true\n  PreviewNaming:\n    active: false # Opt-in, disabled by default.\n    # -- You can optionally configure the naming strategy for previews.\n    # -- Possible values are: `suffix`, `prefix`, `anywhere`. By default, it will be `suffix`.\n    # previewNamingStrategy: suffix\n  PreviewPublic:\n    active: true\n  RememberMissing:\n    active: true\n  RememberContentMissing:\n    active: true\n  UnstableCollections:\n    active: false # Opt-in, disabled by default. Turn on if you want to enforce this (e.g. you have strong skipping disabled)\n  ViewModelForwarding:\n    active: true\n    # -- You can optionally use this rule on things other than types ending in \"ViewModel\" or \"Presenter\" (which are the defaults). You can add your own via a regex here:\n    # allowedStateHolderNames: .*ViewModel,.*Presenter\n    # -- You can optionally add an allowlist for Composable names that won't be affected by this rule\n    # allowedForwarding: .*Content,.*FancyStuff\n    # -- You can optionally add an allowlist for ViewModel/StateHolder names that won't be affected by this rule\n    # allowedForwardingOfTypes: PotatoViewModel,(Apple|Banana)ViewModel,.*FancyViewModel\n  ViewModelInjection:\n    active: true\n    # -- You can optionally add your own ViewModel factories here\n    # viewModelFactories: hiltViewModel,potatoViewModel\n</code></pre>"},{"location":"detekt/#disabling-a-specific-rule","title":"Disabling a specific rule","text":"<p>To disable a rule you have to follow the instructions from the detekt documentation, and use the id of the rule you want to disable.</p> <p>For example, to disable <code>ComposableNaming</code> in a particular method, you can suppress it.</p> <pre><code>@Suppress(\"ComposableNaming\")\n@Composable\nfun myNameIsWrong() { }\n</code></pre> <p>You can also disable rules altogether by changing the <code>active: true</code> to <code>active: false</code> in your detekt configuration yml file.</p>"},{"location":"ktlint/","title":"Using with ktlint","text":""},{"location":"ktlint/#using-with-kotlinter","title":"Using with Kotlinter","text":"<p>If using kotlinter, you can specify the dependency on this set of rules by using the <code>buildscript</code> classpath.</p> <pre><code>buildscript {\n    dependencies {\n        classpath \"io.nlopez.compose.rules:ktlint:&lt;version&gt;\"\n    }\n}\n</code></pre>"},{"location":"ktlint/#using-with-ktlint-gradle","title":"Using with ktlint-gradle","text":"<p>Note: You need at least version 11.1.0 of this plugin.</p> <p>If using ktlint-gradle, you can specify the dependency on this set of rules by using the <code>ktlintRuleset</code>.</p> <pre><code>dependencies {\n    ktlintRuleset \"io.nlopez.compose.rules:ktlint:&lt;VERSION&gt;\"\n}\n</code></pre>"},{"location":"ktlint/#using-with-spotless","title":"Using with spotless","text":"<p>See Spotless Ktlint Integration.</p>"},{"location":"ktlint/#using-with-ktlint-cli-or-the-ktlint-intellij-plugin","title":"Using with ktlint CLI or the ktlint IntelliJ plugin","text":"<p>The releases page contains an uber jar for each version release that can be used for these purposes. In the releases page you can identify them by the suffix <code>-all.jar</code>.</p> <p>To use with ktlint CLI: <pre><code>ktlint -R ktlint-compose-&lt;VERSION&gt;-all.jar\n</code></pre></p> <p>You can use this same uber jar from the releases page with the ktlint IntelliJ plugin if the rules are compiled against the same ktlint version used for that release. You can configure the custom ruleset in the preferences page of the plugin.</p>"},{"location":"ktlint/#supported-versions-matrix","title":"Supported versions matrix","text":"Version Ktlint version Kotlin (Syntax) 0.4.22+ 1.5.0 2.1.0 0.4.18+ 1.4.1 2.0.21 0.4.17 1.4.0 2.0.21 0.4.12+ 1.3.1 2.0.20 0.4.6+ 1.3.1 2.0.0 0.4.5 1.3.0 2.0.0 0.3.12+ 1.2.1 1.9.23 0.3.9+ 1.1.1 1.9.22 <p>Older version support can be found in the release notes.</p>"},{"location":"ktlint/#configuring-rules","title":"Configuring rules","text":""},{"location":"ktlint/#providing-custom-content-emitters","title":"Providing custom content emitters","text":"<p>There are some rules (<code>compose:content-emitter-returning-values-check</code>, <code>compose:modifier-not-used-at-root</code> and <code>compose:multiple-emitters-check</code>) that use predefined list of known composables that emit content. But you can add your own too! In your <code>.editorconfig</code> file, you'll need to add a <code>compose_content_emitters</code> property followed by a list of composable names separated by commas. You would typically want the composables that are part of your custom design system to be in this list.</p> <pre><code>[*.{kt,kts}]\ncompose_content_emitters = MyComposable,MyOtherComposable\n</code></pre>"},{"location":"ktlint/#providing-exceptions-to-content-emitters","title":"Providing exceptions to content emitters","text":"<p>Sometimes we'll want to not count a Composable towards the multiple content emitters (<code>compose:multiple-emitters-check</code>) rule. This is useful, for example, if the composable function actually emits content but that content is painted in a different window (like a dialog or a modal). For those cases, we can use a denylist <code>compose_content_emitters_denyylist</code> to add those composable names separated by commas.</p> <pre><code>[*.{kt,kts}]\ncompose_content_emitters_denylist = MyModalComposable,MyDialogComposable\n</code></pre>"},{"location":"ktlint/#providing-custom-viewmodel-factories","title":"Providing custom ViewModel factories","text":"<p>The <code>vm-injection-check</code> rule will check against common ViewModel factories (eg <code>viewModel</code> from AAC, <code>weaverViewModel</code> from Weaver, <code>hiltViewModel</code> from Hilt + Compose, etc), but you can configure your <code>.editorconfig</code> file to add your own, as a list of comma-separated strings:</p> <pre><code>[*.{kt,kts}]\ncompose_view_model_factories = myViewModel,potatoViewModel\n</code></pre>"},{"location":"ktlint/#providing-a-list-of-allowed-compositionlocals","title":"Providing a list of allowed <code>CompositionLocal</code>s","text":"<p>For <code>compositionlocal-allowlist</code> rule you can define a list of <code>CompositionLocal</code>s that are allowed in your codebase.</p> <pre><code>[*.{kt,kts}]\ncompose_allowed_composition_locals = LocalSomething,LocalSomethingElse\n</code></pre>"},{"location":"ktlint/#ignore-annotated-functions-with-specific-annotations-for-missing-modifier-checks","title":"Ignore annotated functions with specific annotations for missing Modifier checks","text":"<p>In the <code>modifier-missing-check</code> rule, you can define a list of annotations that, if present, will make it so the function is exempt from this rule.</p> <pre><code>[*.{kt,kts}]\ncompose_modifier_missing_ignore_annotated = Potato,Banana\n</code></pre>"},{"location":"ktlint/#allowing-matching-function-names","title":"Allowing matching function names","text":"<p>The <code>naming-check</code> rule requires all composables that return a value to be lowercased. If you want to allow certain patterns though, you can configure a comma-separated list of matching regexes in your <code>.editorconfig</code> file:</p> <pre><code>[*.{kt,kts}]\ncompose_allowed_composable_function_names = .*Presenter,.*SomethingElse\n</code></pre>"},{"location":"ktlint/#allowing-custom-state-holder-names","title":"Allowing custom state holder names","text":"<p>The <code>vm-forwarding-check</code> rule will, by default, design as a state holder any class ending on \"ViewModel\" or \"Presenter\". You can, however, add new types of names to the mix via a comma-separated list of matching regexes in your <code>.editorconfig</code> file:</p> <pre><code>[*.{kt,kts}]\ncompose_allowed_state_holder_names = .*ViewModel,.*Presenter,.*Component,.*SomethingElse\n</code></pre>"},{"location":"ktlint/#allowlist-for-composable-names-that-arent-affected-by-the-viewmodelforwarding-rule","title":"Allowlist for composable names that aren't affected by the ViewModelForwarding rule","text":"<p>The <code>vm-forwarding-check</code> will catch VMs/state holder classes that are relayed to other composables. However, in some situations this can be a valid use-case. The rule can be configured so that all the names of composables that match a list of regexes are exempt to this rule. You can configure this in your <code>.editorconfig</code> file:</p> <pre><code>[*.{kt,kts}]\ncompose_allowed_forwarding = .*Content,.*SomethingElse\n</code></pre>"},{"location":"ktlint/#allowlist-for-viewmodelstate-holder-names-that-arent-affected-by-the-viewmodelforwarding-rule","title":"Allowlist for ViewModel/state holder names that aren't affected by the ViewModelForwarding rule","text":"<p>The <code>vm-forwarding-check</code> will catch VMs/state holder classes that are relayed to other composables. However, in some situations this can be a valid use-case. The rule can be configured so that all the names of ViewModels that match a list of regexes are exempt to this rule. You can configure this in your <code>.editorconfig</code> file:</p> <pre><code>[*.{kt,kts}]\ncompose_allowed_forwarding_of_types = .*MyViewModel,PotatoViewModel\n</code></pre>"},{"location":"ktlint/#configure-the-visibility-of-the-composables-where-to-check-for-missing-modifiers","title":"Configure the visibility of the composables where to check for missing modifiers","text":"<p>The <code>modifier-missing-check</code> rule will, by default, only look for missing modifiers for public composables. If you want to lower the visibility threshold to check also internal compoosables, or all composables, you can configure it in your <code>.editorconfig</code> file:</p> <pre><code>[*.{kt,kts}]\ncompose_check_modifiers_for_visibility = only_public\n</code></pre> <p>Possible values are:</p> <ul> <li><code>only_public</code>: (default) Will check for missing modifiers only for public composables.</li> <li><code>public_and_internal</code>: Will check for missing modifiers in both public and internal composables.</li> <li><code>all</code>: Will check for missing modifiers in all composables.</li> </ul>"},{"location":"ktlint/#configure-custom-modifier-names","title":"Configure custom Modifier names","text":"<p>Most of the modifier-related rules will look for modifiers based their type: either Modifier or GlanceModifier type. Some libraries might add their own flavor of Modifier to the mix, and it might make sense to enforce the same rules we have for the other default modifiers. To support that, you can configure this in your <code>.editorconfig</code> file:</p> <pre><code>[*.{kt,kts}]\ncompose_custom_modifiers = BananaModifier,PotatoModifier\n</code></pre>"},{"location":"ktlint/#configure-types-to-treat-as-lambdas-eg-for-paramorder-check","title":"Configure types to treat as lambdas (e.g. for ParamOrder check)","text":"<p>The <code>param-order-check</code> rule will do its best to identify trailing lambdas. However, in cases where a typedef / functional interface is being used, we might want to have this rule to treat them as if they were lambdas: not reporting them if they are the last in a method signature and they don't have a default value. To give ktlint some hints, you can configure this in your <code>.editorconfig</code> file:</p> <pre><code>[*.{kt,kts}]\ncompose_treat_as_lambda = MyLambdaType,MyOtherLambdaType\n</code></pre>"},{"location":"ktlint/#configure-types-to-treat-as-composable-lambdas-eg-for-contenttrailinglambda-check","title":"Configure types to treat as composable lambdas (e.g. for ContentTrailingLambda check)","text":"<p>The <code>content-trailing-lambda</code> rule will do its best to identify <code>@Composable</code> trailing lambdas. However, in cases where a typedef / functional interface is being used, we might want to have this rule to treat them as if they were composable lambdas: not reporting them if they are the last in a method signature and they don't have a default value. To give ktlint some hints, you can configure this in your <code>.editorconfig</code> file:</p> <pre><code>[*.{kt,kts}]\ncompose_treat_as_composable_lambda = MyLambdaComposableType,MyOtherComposableLambdaType\n</code></pre>"},{"location":"ktlint/#enabling-the-material-2-detector","title":"Enabling the Material 2 detector","text":"<p>The <code>material-two</code> rule will flag any usage of a Material 2 API. This rule is disabled by default, so you'll need to explicitly enable it in your <code>.editorconfig</code> file:</p> <pre><code>[*.{kt,kts}]\ncompose_disallow_material2 = true\n</code></pre> <p>You might also want to disallow Material 2, but allow a specific set / subset of APIs. The rule allows this too.</p> <p>For example, let's say you want to allow all filled icons (whose fully qualified names are androidx.compose.material.icons.filled.*) and the <code>Button</code> composable (androidx.compose.material.Button). This is how you'd allow those:</p> <pre><code>[*.{kt,kts}]\ncompose_disallow_material2 = true\ncompose_allowed_from_m2 = icons.filled,Button\n</code></pre>"},{"location":"ktlint/#enabling-the-unstable-collections-detector","title":"Enabling the unstable collections detector","text":"<p>The <code>unstable-collections</code> rule will flag any usage of any unstable collection (e.g. List/Set/Map). This rule is disabled by default, so you'll need to explicitly enable it in your <code>.editorconfig</code> file:</p> <pre><code>[*.{kt,kts}]\ncompose_disallow_unstable_collections = true\n</code></pre>"},{"location":"ktlint/#enabling-and-configuring-the-preview-naming-detector","title":"Enabling and configuring the preview naming detector","text":"<p>If you want to enforce a naming strategy for previews, you can enable the <code>compose:preview-naming</code> rule and configure the <code>compose_preview_naming_strategy</code> property in your <code>.editorconfig</code> file:</p> <pre><code>[*.{kt,kts}]\ncompose_preview_naming_enabled = true\ncompose_preview_naming_strategy = suffix\n</code></pre> <p>Possible values of <code>compose_preview_naming_strategy</code> are:</p> <ul> <li><code>suffix</code>: Previews should have <code>Preview</code> as suffix.</li> <li><code>prefix</code>: Previews should have <code>Preview</code> as prefix.</li> <li><code>anywhere</code>: Previews should contain <code>Preview</code> in their names.</li> </ul>"},{"location":"ktlint/#disable-standardfunction-naming-rule-for-composable","title":"Disable <code>standard:function-naming</code> rule for Composable","text":"<p>The function name for a Composable starts with an uppercase. This causes the ktlint rule <code>standard:function-naming</code> to report a violation. This rule can be configured to ignore Composable functions in your <code>.editorconfig</code> file:</p> <pre><code>[*.{kt,kts}]\nktlint_function_naming_ignore_when_annotated_with = Composable\n</code></pre>"},{"location":"ktlint/#disabling-a-specific-rule","title":"Disabling a specific rule","text":"<p>To disable a rule you have to follow the instructions from the ktlint documentation, and use the id of the rule you want to disable with the <code>compose</code> tag.</p> <p>For example, to disable the <code>naming-check</code> rule, the tag you'll need to disable is <code>ktlint:compose:naming-check</code>.</p> <pre><code>    @Suppress(\"ktlint:compose:naming-check\")\n    fun YourComposableHere() { ... }\n</code></pre>"},{"location":"rules/","title":"Rules","text":""},{"location":"rules/#state","title":"State","text":""},{"location":"rules/#hoist-all-the-things","title":"Hoist all the things","text":"<p>Compose is built upon the idea of a unidirectional data flow, which can be summarised as: data/state flows down, and events fire up. To implement that, Compose advocates for the pattern of hoisting state upwards, enabling the majority of your composable functions to be stateless. This has many benefits, including far easier testing.</p> <p>In practice, there are a few common things to look out for:</p> <ul> <li>Do not pass ViewModels (or objects from DI) down.</li> <li>Do not pass <code>MutableState&lt;Bar&gt;</code> instances down.</li> <li>Do not pass inherently mutable types, that can't be observed types, down.</li> </ul> <p>Instead pass down the relevant data to the function, and optional lambdas for callbacks.</p> <p>More information: State and Jetpack Compose</p> <p> compose:vm-forwarding-check ktlint  ViewModelForwarding detekt</p>"},{"location":"rules/#state-should-be-remembered-in-composables","title":"State should be remembered in composables","text":"<p>Be careful when using <code>mutableStateOf</code> (or any of the other <code>State&lt;T&gt;</code> builders) to make sure that you <code>remember</code> the instance. If you don't <code>remember</code> the state instance, a new state instance will be created when the function is recomposed.</p> <p> compose:remember-missing-check ktlint  RememberMissing detekt</p>"},{"location":"rules/#use-mutablestateof-type-specific-variants-when-possible","title":"Use mutableStateOf type-specific variants when possible","text":"<p><code>mutableIntStateOf</code>, <code>mutableLongStateOf</code>, <code>mutableDoubleStateOf</code>, <code>mutableFloatStateOf</code> are essentially counterparts to <code>mutableStateOf</code>, but with the added advantage of circumventing autoboxing on JVM platforms. This distinction renders them more memory efficient, making them the preferable choice when dealing with primitive types such as double, float, int, and long.</p> <p>Functionally are the same, but they are preferred when dealing with these specific types.</p> <p> compose:mutable-state-autoboxing ktlint  MutableStateAutoboxing detekt</p>"},{"location":"rules/#composables","title":"Composables","text":""},{"location":"rules/#do-not-use-inherently-mutable-types-as-parameters","title":"Do not use inherently mutable types as parameters","text":"<p>This practice follows on from the 'Hoist all the things' item above, where we said that state flows down. It might be tempting to pass mutable state down to a function to mutate the value.</p> <p>This is an anti-pattern though as it breaks the pattern of state flowing down, and events firing up. The mutation of the value is an event which should be modelled within the function API (a lambda callback).</p> <p>There are a few reasons for this, but the main one is that it is very easy to use a mutable object which does not trigger recomposition. Without triggering recomposition, your composables will not automatically update to reflect the updated value.</p> <p>Passing <code>ArrayList&lt;T&gt;</code> or <code>ViewModel</code> are common examples of this (but not limited to those types).</p> <p> compose:mutable-params-check ktlint  MutableParams detekt</p>"},{"location":"rules/#do-not-use-mutablestate-as-a-parameter","title":"Do not use MutableState as a parameter","text":"<p>This practice also follows on from the 'Hoist all the things' item above. When using <code>MutableState&lt;T&gt;</code> in a @Composable function signature as a parameter, this is promoting joint ownership over a state between a component and its user.</p> <p>Instead, if possible, consider making the component stateless and concede the state change to the caller. If mutation of the parent\u2019s owned property is required in the component, consider creating a ComponentState class with the domain specific meaningful field that is backed by <code>mutableStateOf(...)</code>.</p> <p>When a component accepts MutableState as a parameter, it gains the ability to change it. This results in the split ownership of the state, and the usage side that owns the state now has no control over how and when it will be changed from within the component\u2019s implementation.</p> <p>More info: Compose API guidelines</p> <p> compose:mutable-state-param-check ktlint  MutableStateParam detekt</p>"},{"location":"rules/#be-mindful-of-the-arguments-you-use-inside-of-a-restarting-effect","title":"Be mindful of the arguments you use inside of a restarting effect","text":"<p>In Compose, effects like <code>LaunchedEffect</code>, <code>produceState</code>, or <code>DisposableEffect</code> can take multiple keys as arguments to control when the effect restarts. The typical form for these APIs is:</p> <p><pre><code>EffectName(key1, key2, key3, ...) { block }\n</code></pre> Using the wrong keys to restart the effect can lead to:</p> <ul> <li>Bugs if the effect restarts less often than needed.</li> <li>Inefficiency if the effect restarts more often than necessary.</li> </ul> <p>To ensure proper behavior:</p> <ul> <li>Include mutable and immutable variables from the effect block as parameters.</li> <li>Additional parameters can be added for explicit restart control.</li> <li>Use <code>rememberUpdatedState</code> to prevent unnecessary restarts.<ul> <li>This is usually useful whenever it wouldn't be a good idea to restart the effect, e.g. it's invoked inside of a flow collector method.</li> </ul> </li> <li>If a variable never changes due to remember with no keys, no need to pass it as a key to the effect.</li> </ul> <p>Let's see some sample cases.</p> <pre><code>// \u274c onClick changes, but the effect won't be pointing to the right one!\n@Composable\nfun MyComposable(onClick: () -&gt; Unit) {\n    LaunchedEffect(Unit) {\n        delay(10.seconds) // something that takes time, a flow collection, etc\n        onClick()\n    }\n    // ...\n}\n// \u2705 onClick changes and the LaunchedEffect won't be rebuilt -- but will point at the correct onClick!\n@Composable\nfun MyComposable(onClick: () -&gt; Unit) {\n    val latestOnClick by rememberUpdatedState(onClick)\n    LaunchedEffect(Unit) {\n        delay(10.seconds) // something that takes time, a flow collection, etc\n        latestOnClick()\n    }\n    // ...\n}\n// \u2705 _If we don't care about rebuilding the effect_, we can also use the parameter as key\n@Composable\nfun MyComposable(onClick: () -&gt; Unit) {\n    // This effect will be rebuilt every time onClick changes, so it will always point to the latest one.\n    LaunchedEffect(onClick) {\n        delay(10.seconds) // something that takes time, a flow collection, etc\n        onClick()\n    }\n}\n</code></pre> <p>More info: Restarting effects and rememberUpdatedState</p> <p> compose:lambda-param-in-effect ktlint  LambdaParameterInRestartableEffect detekt</p>"},{"location":"rules/#do-not-emit-content-and-return-a-result","title":"Do not emit content and return a result","text":"<p>Composable functions should either emit layout content, or return a value, but not both.</p> <p>If a composable should offer additional control surfaces to its caller, those control surfaces or callbacks should be provided as parameters to the composable function by the caller.</p> <p>More info: Compose API guidelines</p> <p> compose:content-emitter-returning-values-check ktlint  compose:content-emitter-returning-values-check detekt</p> <p>Note: To add your custom composables so they are used in this rule (things like your design system composables), you can add <code>composeEmitters</code> to this rule config in Detekt, or <code>compose_emitters</code> to your .editorconfig in ktlint.</p>"},{"location":"rules/#do-not-emit-multiple-pieces-of-content","title":"Do not emit multiple pieces of content","text":"<p>A composable function should emit either 0 or 1 pieces of layout, but no more. A composable function should be cohesive, and not rely on what function it is called from.</p> <p>You can see an example of what not to do below. <code>InnerContent()</code> emits a number of layout nodes and assumes that it will be called from a <code>Column</code>:</p> <pre><code>// This will render:\n// &lt;text&gt;\n// &lt;image&gt;\n// &lt;button&gt;\nColumn {\n    InnerContent()\n}\n\n// \u274c Unclear UI, as we emit multiple pieces of content at the same time\n@Composable\nprivate fun InnerContent() {\n    Text(...)\n    Image(...)\n    Button(...)\n}\n</code></pre> <p>However InnerContent could just as easily be called from a <code>Row</code> or a <code>Box</code> which would break all assumptions. Some other examples of interaction with <code>InnerContent</code> could be:</p> <pre><code>// \u274c This will render: &lt;text&gt;&lt;image&gt;&lt;button&gt;\nRow {\n    InnerContent()\n}\n// \u274c This will render all elements on top of each other.\nBox {\n    InnerContent()\n}\n</code></pre> <p>Instead, InnerContent should be cohesive and emit a single layout node itself:</p> <p><pre><code>// \u2705\n@Composable\nprivate fun InnerContent() {\n    Column {\n        Text(...)\n        Image(...)\n        Button(...)\n    }\n}\n</code></pre> Nesting of layouts has a drastically lower cost vs the view system, so developers should not try to minimize UI layers at the cost of correctness.</p> <p>There is a slight exception to this rule, which is when the function is defined as an extension function of an appropriate scope, like so: <pre><code>// \u2705\n@Composable\nprivate fun ColumnScope.InnerContent() {\n    Text(...)\n    Image(...)\n    Button(...)\n}\n</code></pre> This effectively ties the function to be called from a Column, but is still not recommended (although permitted).</p> <p> compose:multiple-emitters-check ktlint  MultipleEmitters detekt</p> <p>Note: To add your custom composables so they are used in this rule (things like your design system composables), you can add <code>composeEmitters</code> to this rule config in Detekt, or <code>compose_emitters</code> to your .editorconfig in ktlint.</p>"},{"location":"rules/#slots-for-main-content-should-be-the-trailing-lambda","title":"Slots for main content should be the trailing lambda","text":"<p>The slots used to display the main content for a composable, which are typically in the form of <code>content: @Composable () -&gt; Unit</code> (or their nullable counterpart) should always be placed as the last parameter of a composable function, so they can be written as the trailing lambda. This makes following the flow of the main pieces of UI / content more natural and easy to reason about.</p> <pre><code>// \u274c\n@Composable\nfun Avatar(content: @Composable () -&gt; Unit, subtitle: String, modifier: Modifier = Modifier) { ... }\n\n// \u2705 The usage of the main content as a trailing lambda is more natural\n@Composable\nfun Avatar(subtitle: String, modifier: Modifier = Modifier, content: @Composable () -&gt; Unit) { ... }\n\n@Composable\nfun Profile(user: User, modifier: Modifier = Modifier) {\n    Column(modifier) {\n        Avatar(subtitle = user.name) {\n            AsyncImage(url = user.avatarUrl)\n        }\n    }\n}\n</code></pre> <p> compose:content-trailing-lambda ktlint  ContentTrailingLambda detekt</p>"},{"location":"rules/#content-slots-should-not-be-reused-in-branching-code","title":"Content slots should not be reused in branching code","text":"<p>Content slot parameters should not be disposed and recomposed when the parent composable changes, structurally or visually (changes that are typically due to branching code).</p> <p>Developers should ensure that the lifecycle of visible slot parameter composables either matches the lifecycle of the composable accepting the slot or is connected to the slot's visibility within the viewport.</p> <p>To ensure proper behavior, you could either:</p> <ul> <li>Use <code>remember { movableContentOf { ... } }</code> to make sure the content is preserved correctly; or</li> <li>Create a custom layout where the internal state of the slot is preserved.</li> </ul> <pre><code>// \u274c\n@Composable\nfun Avatar(user: User, content: @Composable () -&gt; Unit) {\n    if (user.isFollower) {\n        content()\n    } else {\n        content()\n    }\n}\n\n// \u2705\n@Composable\nfun Avatar(user: User, content: @Composable () -&gt; Unit) {\n    val content = remember { movableContentOf { content() } }\n    if (user.isFollower) {\n        content()\n    } else {\n        content()\n    }\n}\n</code></pre> <p>More information: Lifecycle expectations for slot parameters</p> <p> compose:content-slot-reused ktlint  ContentSlotReused detekt</p>"},{"location":"rules/#avoid-using-the-trailing-lambda-for-event-lambdas-in-ui-composables","title":"Avoid using the trailing lambda for event lambdas in UI Composables","text":"<p>In Compose, trailing lambdas in composable functions are typically used for content slots. To avoid confusion and maintain consistency, event lambdas (e.g., <code>onClick</code>, <code>onValueChange</code>) should generally not be placed in the trailing position.</p> <p>Recommendations:</p> <ul> <li>Required Event Lambdas: Place required event lambdas before the <code>Modifier</code> parameter. This clearly distinguishes them from content slots.</li> <li>Optional Event Lambdas: When possible, avoid placing optional event lambdas as the last parameter. If an optional event lambda must be positioned at the end, consider adding a clarifying comment to the function definition.</li> </ul> <pre><code>// \u274c Using an event lambda (like onClick) as the trailing lambda when in a composable makes it error prone and awkward to read\n@Composable\nfun MyButton(modifier: Modifier = Modifier, onClick: () -&gt; Unit) { /* ... */ }\n\n@Composable\nfun SomeUI(modifier: Modifier = Modifier) {\n    MyButton {\n        // This is an onClick, but by reading it people would assume it's a content slot\n    }\n}\n\n// \u2705 By moving the event lambda to be before Modifier, we avoid confusion\n@Composable\nfun MyBetterButton(onClick: () -&gt; Unit, modifier: Modifier = Modifier) { /* ... */ }\n\n@Composable\nfun SomeUI(modifier: Modifier = Modifier) {\n    MyBetterButton(\n        onClick = {\n            // Now this param is straightforward to understand\n        },\n    )\n}\n</code></pre> <p> compose:lambda-param-event-trailing ktlint  LambdaParameterEventTrailing detekt</p>"},{"location":"rules/#naming-compositionlocals-properly","title":"Naming CompositionLocals properly","text":"<p><code>CompositionLocal</code>s should be named by using the adjective <code>Local</code> as prefix, followed by a descriptive noun that describes the value they hold. This makes it easier to know when a value comes from a <code>CompositionLocal</code>. Given that these are implicit dependencies, we should make them obvious.</p> <p>More information: Naming CompositionLocals</p> <p> compose:compositionlocal-naming ktlint  CompositionLocalNaming detekt</p>"},{"location":"rules/#naming-multipreview-annotations-properly","title":"Naming multipreview annotations properly","text":"<p>Multipreview annotations should be named by using <code>Previews</code> as a prefix. These annotations have to be explicitly named to make sure that they are clearly identifiable as a <code>@Preview</code> alternative on its usages.</p> <p>More information: Multipreview annotations and Google's own predefined annotations</p> <p> compose:preview-annotation-naming ktlint  PreviewAnnotationNaming detekt</p>"},{"location":"rules/#naming-composable-functions-properly","title":"Naming @Composable functions properly","text":"<p>Composable functions that return <code>Unit</code> should start with an uppercase letter. They are considered declarative entities that can be either present or absent in a composition and therefore follow the naming rules for classes.</p> <p>However, Composable functions that return a value should start with a lowercase letter instead. They should follow the standard Kotlin Coding Conventions for the naming of functions for any function annotated <code>@Composable</code> that returns a value other than <code>Unit</code></p> <p>More information: Naming Unit @Composable functions as entities and Naming @Composable functions that return values</p> <p> compose:naming-check ktlint  ComposableNaming detekt</p>"},{"location":"rules/#naming-composable-annotations-properly","title":"Naming Composable annotations properly","text":"<p>Custom Composable annotations (tagged with <code>@ComposableTargetMarker</code>) should have the <code>Composable</code> suffix (for example, <code>@GoogleMapComposable</code> or <code>@MosaicComposable</code>).</p> <p> compose:composable-annotation-naming-check ktlint  ComposableAnnotationNaming detekt</p>"},{"location":"rules/#ordering-composable-parameters-properly","title":"Ordering @Composable parameters properly","text":"<p>When writing Kotlin, it's a good practice to write the parameters for your methods by putting the mandatory parameters first, followed by the optional ones (aka the ones with default values). By doing so, we minimize the number times we will need to write the name for arguments explicitly.</p> <p>Modifiers occupy the first optional parameter slot to set a consistent expectation for developers that they can always provide a modifier as the final positional parameter to an element call for any given element's common case.</p> <p>Additionally, if there is a <code>content</code> lambda, it should be used as a trailing lambda.</p> <ol> <li>Required parameters (no default values)</li> <li>Optional parameters (have default values)<ol> <li><code>modifier: Modifier = Modifier</code></li> <li>The rest of optional params</li> </ol> </li> <li>[Optionally] A trailing lambda. If there is a <code>content</code> slot, it should be it.</li> </ol> <pre><code>  flowchart LR\n    A[Required parameters] --&gt; B[Modifier, if any]\n    B --&gt; C[Optional parameters]\n    C --&gt; D[Optionally a trailing lambda, eg a content slot]</code></pre> <p>An example of the above could be this:</p> <pre><code>// \u2705\n@Composable\nfun Avatar(\n    imageUrl: String,               // Required parameters go first\n    contentDescription: String,\n    onClick: () -&gt; Unit,\n    modifier: Modifier = Modifier,  // Optional parameters, start with modifier\n    enabled: Boolean = true,        // Other optional parameters\n    loadingContent: @Composable (() -&gt; Unit)? = null,\n    errorContent: @Composable (() -&gt; Unit)? = null,\n    content: @Composable () -&gt; Unit, // A trailing lambda _can_ be last. Recommended for `content` slots.\n) { ... }\n</code></pre> <p>More information: Kotlin default arguments, Modifier docs and Elements accept and respect a Modifier parameter.</p> <p> compose:param-order-check ktlint  ComposableParamOrder detekt</p>"},{"location":"rules/#naming-parameters-properly","title":"Naming parameters properly","text":"<p>The parameters in composable functions that send events are typically named <code>on</code> + verb in the present tense, like in the very common examples in Compose foundation code: <code>onClick</code> or <code>onTextChange</code>. To try to enforce common standard, and for consistency\u2019s sake, we'll want to adjust the tense of the verbs to present.</p> <pre><code>// \u274c\n@Composable\nfun Avatar(onShown: () -&gt; Unit, onChanged: () -&gt; Unit) { /* ... */ }\n\n// \u2705\n@Composable\nfun Avatar(onShow: () -&gt; Unit, onChange: () -&gt; Unit) { /* ... */ }\n</code></pre> <p> compose:parameter-naming ktlint  ParameterNaming detekt</p>"},{"location":"rules/#movable-content-should-be-remembered","title":"Movable content should be remembered","text":"<p>The methods used to create movable composable content (<code>movableContentOf</code> and <code>movableContentWithReceiverOf</code>) need to be used inside a <code>remember</code> function.</p> <p>To work as intended, they need to persist through compositions - as if they get detached from the composition, they will be immediately recycled.</p> <p> compose:remember-content-missing-check ktlint  RememberContentMissing detekt</p>"},{"location":"rules/#make-dependencies-explicit","title":"Make dependencies explicit","text":""},{"location":"rules/#viewmodels","title":"ViewModels","text":"<p>When designing our composables, we should always try to be explicit about the dependencies they take in. If you acquire a ViewModel or an instance from DI in the body of the composable, you are making this dependency implicit, which has the downsides of making it hard to test and harder to reuse.</p> <p>To solve this problem, you should inject these dependencies as default values in the composable function.</p> <p>Let's see it with an example.</p> <p><pre><code>// \u274c The VM dependency is implicit here.\n@Composable\nprivate fun MyComposable() {\n    val viewModel = viewModel&lt;MyViewModel&gt;()\n    // ...\n}\n</code></pre> In this composable, the dependencies are implicit. When testing it you would need to fake the internals of viewModel somehow to be able to acquire your intended ViewModel.</p> <p>But, if you change it to pass these instances via the composable function parameters, you could provide the instance you want directly in your tests without any extra effort. It would also have the upside of the function being explicit about its external dependencies in its signature.</p> <pre><code>// \u2705 The VM dependency is explicit\n@Composable\nprivate fun MyComposable(\n    viewModel: MyViewModel = viewModel(),\n) {\n    // ...\n}\n</code></pre> <p> compose:vm-injection-check ktlint  ViewModelInjection detekt</p>"},{"location":"rules/#compositionlocals","title":"<code>CompositionLocal</code>s","text":"<p><code>CompositionLocal</code> makes a composable function's behavior harder to reason about. As they create implicit dependencies, callers of composables that use them need to make sure that a value for every CompositionLocal is satisfied, which is not apparent from the composable API alone.</p> <p>Although uncommon, there are legit usecases for them, so this rule provides an allowlist so that you can add your <code>CompositionLocal</code> names to it so that they are not flagged by the rule.</p> <p> compose:compositionlocal-allowlist ktlint  CompositionLocalAllowlist detekt</p> <p>Note: To add your custom <code>CompositionLocal</code> to your allowlist, you can add <code>allowedCompositionLocals</code> to this rule config in Detekt, or <code>compose_allowed_composition_locals</code> to your .editorconfig in ktlint.</p>"},{"location":"rules/#preview-composables-should-not-be-public","title":"Preview composables should not be public","text":"<p>When a composable function exists solely because it's a <code>@Preview</code>, it doesn't need to have public visibility because it won't be used in actual UI. To prevent folks from using it unknowingly, we should restrict its visibility to <code>private</code>.</p> <p> compose:preview-public-check ktlint  PreviewPublic detekt</p> <p>Note: If you are using Detekt, this may conflict with Detekt's UnusedPrivateMember rule. Be sure to set Detekt's ignoreAnnotated configuration to ['Preview'] for compatibility with this rule.</p>"},{"location":"rules/#modifiers","title":"Modifiers","text":""},{"location":"rules/#when-should-i-expose-modifier-parameters","title":"When should I expose modifier parameters?","text":"<p>Modifiers are the beating heart of Compose UI. They encapsulate the idea of composition over inheritance, by allowing developers to attach logic and behavior to layouts.</p> <p>They are especially important for your public components, as they allow callers to customize the component to their wishes.</p> <p>More info: Always provide a Modifier parameter</p> <p> compose:modifier-missing-check ktlint  ModifierMissing detekt</p>"},{"location":"rules/#modifier-order-matters","title":"Modifier order matters","text":"<p>The order of modifier functions is very important. Each function makes changes to the Modifier returned by the previous function, the sequence affects the final result. Let's see an example of this:</p> <p><pre><code>// \u274c The UI will be off, as the pressed state ripple will extend beyond the intended shape\n@Composable\nfun MyCard(modifier: Modifier = Modifier) {\n    Column(\n        modifier\n            // Tapping on it does a ripple, the ripple is bound incorrectly to the composable\n            .clickable { /* TODO */ }\n            // Create rounded corners\n            .clip(shape = RoundedCornerShape(8.dp))\n            // Background with rounded corners\n            .background(color = backgroundColor, shape = RoundedCornerShape(8.dp))\n    ) {\n        // rest of the implementation\n    }\n}\n</code></pre> The entire area, including the clipped area and the clipped background, responds to clicks. This means that the ripple will fill it all, even the areas that we wanted to trim from the shape.</p> <p>We can address this by simply reordering the modifiers.</p> <pre><code>// \u2705 The UI will be now correct, as the pressed state ripple will have the same shape as the element\n@Composable\nfun MyCard(modifier: Modifier = Modifier) {\n    Column(\n        modifier\n            // Create rounded corners\n            .clip(shape = RoundedCornerShape(8.dp))\n            // Background with rounded corners\n            .background(color = backgroundColor, shape = RoundedCornerShape(8.dp))\n            // Tapping on it does a ripple, the ripple is bound correctly now to the composable\n            .clickable { /* TODO */ }\n    ) {\n        // rest of the implementation\n    }\n}\n</code></pre> <p>More info: Modifier documentation</p> <p> compose:modifier-clickable-order ktlint  ModifierClickableOrder detekt</p>"},{"location":"rules/#modifiers-should-be-used-at-the-top-most-layout-of-the-component","title":"Modifiers should be used at the top-most layout of the component","text":"<p>Modifiers should be applied once as a first modifier in the chain to the root-most layout in the component implementation. Since modifiers aim to modify the external behaviors and appearance of the component, they must be applied to the top-most layout and be the first modifiers in the hierarchy. It is allowed to chain other modifiers to the modifier passed as a param if needed.</p> <p>More info: Compose Component API Guidelines</p> <p> compose:modifier-not-used-at-root ktlint  ModifierNotUsedAtRoot detekt</p>"},{"location":"rules/#dont-re-use-modifiers","title":"Don't re-use modifiers","text":"<p>Modifiers which are passed in are designed so that they should be used by a single layout node in the composable function. If the provided modifier is used by multiple composables at different levels, unwanted behaviour can happen.</p> <p>In the following example we've exposed a public modifier parameter, and then passed it to the root Column, but we've also passed it to each of the descendant calls, with some extra modifiers on top:</p> <p><pre><code>// \u274c When changing `modifier` at the call site, it will the whole layout in unintended ways\n@Composable\nprivate fun InnerContent(modifier: Modifier = Modifier) {\n    Column(modifier) {\n        Text(modifier.clickable(), ...)\n        Image(modifier.size(), ...)\n        Button(modifier, ...)\n    }\n}\n</code></pre> This is not recommended. Instead, the provided modifier should only be used on the Column. The descendant calls should use newly built modifiers, by using the empty Modifier object:</p> <pre><code>// \u2705 When changing `modifier` at the call site, it will only affect the external container of the UI\n@Composable\nprivate fun InnerContent(modifier: Modifier = Modifier) {\n    Column(modifier) {\n        Text(Modifier.clickable(), ...)\n        Image(Modifier.size(), ...)\n        Button(Modifier, ...)\n    }\n}\n</code></pre> <p> compose:modifier-reused-check ktlint  ModifierReused detekt</p>"},{"location":"rules/#modifiers-should-have-default-parameters","title":"Modifiers should have default parameters","text":"<p>Composables that accept a Modifier as a parameter to be applied to the whole component represented by the composable function should name the parameter modifier and assign the parameter a default value of <code>Modifier</code>. It should appear as the first optional parameter in the parameter list; after all required parameters (except for trailing lambda parameters) but before any other parameters with default values. Any default modifiers desired by a composable function should come after the modifier parameter's value in the composable function's implementation, keeping Modifier as the default parameter value.</p> <p>More info: Modifier documentation</p> <p> compose:modifier-without-default-check ktlint  ModifierWithoutDefault detekt</p>"},{"location":"rules/#naming-modifiers-properly","title":"Naming modifiers properly","text":"<p>Composables that accept a Modifier as a parameter to be applied to the whole component represented by the composable function should name the parameter <code>modifier</code>.</p> <p>In cases where Composables accept modifiers to be applied to a specific subcomponent should name the parameter <code>xModifier</code> (e.g. <code>fooModifier</code> for a <code>Foo</code> subcomponent) and follow the same guidelines above for default values and behavior.</p> <p>More info: Modifier documentation</p> <p> compose:modifier-naming ktlint  ModifierNaming detekt</p>"},{"location":"rules/#avoid-modifier-extension-factory-functions","title":"Avoid Modifier extension factory functions","text":"<p>For <code>@Composable</code> extension factory functions, there is an API for creating custom modifiers, <code>composed {}</code>. This API is no longer recommended due to the performance issues it created, and like with the extension factory functions case, Modifier.Node is recommended instead.</p> <p>More info: Modifier.Node, Compose Modifier.Node and where to find it, by Merab Tato Kutalia, Compose modifiers deep dive, with Leland Richardson and Composed modifier docs.</p> <p> compose:modifier-composed-check ktlint  ModifierComposed detekt</p>"},{"location":"rules/#componentdefaults","title":"ComponentDefaults","text":""},{"location":"rules/#componentdefaults-object-should-match-the-composable-visibility","title":"ComponentDefaults object should match the composable visibility","text":"<p>If your composable has an associated <code>Defaults</code> object to contain its default values, this object should have the same visibility as the composable itself. This will allow consumers to be able to interact or build upon the original intended defaults, as opposed to having to maintain their own set of defaults by copy-pasting.</p> <p>More info: Compose Component API Guidelines</p> <p> compose:defaults-visibility ktlint  DefaultsVisibility detekt</p>"},{"location":"rules/#opt-in-rules","title":"Opt-in rules","text":"<p>These rules are disabled by default</p> <p>You'll need to explicitly enable them individually in your project's detekt/ktlint configuration.</p>"},{"location":"rules/#dont-use-material-2","title":"Don't use Material 2","text":"<p>Material Design 3 is the next evolution of Material Design. It includes updated theming, components, and Material You personalization features like dynamic color. It supersedes Material 2, and using Material 3 usage is recommended instead of Material 2.</p> <p>Enabling: ktlint, detekt</p> <p>More info: Migration to Material 3</p> <p> compose:material-two ktlint  Material2 detekt</p>"},{"location":"rules/#avoid-using-unstable-collections","title":"Avoid using unstable collections","text":"<p>Did you know?</p> <p>You can add the kotlin collections to your stability configuration (<code>kotlin.collections.*</code>) to make this rule unnecessary.</p> <p>Collections are defined as interfaces (e.g. <code>List&lt;T&gt;</code>, <code>Map&lt;T&gt;</code>, <code>Set&lt;T&gt;</code>) in Kotlin, which can't guarantee that they are actually immutable. For example, you could write:</p> <pre><code>// \u274c The compiler won't be able to infer that the list is immutable\nval list: List&lt;String&gt; = mutableListOf()\n</code></pre> <p>The variable is constant, its declared type is not mutable but its implementation is still mutable. The Compose compiler cannot be sure of the immutability of this class as it just sees the declared type and as such declares it as unstable.</p> <p>To force the compiler to see a collection as truly 'immutable' you have a couple of options.</p> <p>You can use Kotlinx Immutable Collections:</p> <pre><code>// \u2705 The compiler knows that this list is immutable\nval list: ImmutableList&lt;String&gt; = persistentListOf&lt;String&gt;()\n</code></pre> <p>Alternatively, you can wrap your collection in an annotated stable class to mark it as immutable for the Compose compiler.</p> <pre><code>// \u2705 The compiler knows that this class is immutable\n@Immutable\ndata class StringList(val items: List&lt;String&gt;)\n// ...\nval list: StringList = StringList(yourList)\n</code></pre> <p>Note: It is preferred to use Kotlinx Immutable Collections for this. As you can see, the wrapped case only includes the immutability promise with the annotation, but the underlying List is still mutable.</p> <p>More info: Jetpack Compose Stability Explained, Kotlinx Immutable Collections</p> <p> compose:unstable-collections ktlint  UnstableCollections detekt</p>"},{"location":"rules/#naming-previews-properly","title":"Naming previews properly","text":"<p>You can configure the naming strategy for previews, so that they follow your project's naming conventions.</p> <p>By default, enabling this rule will make sure that previews use <code>Preview</code> as suffix.</p> <p>In case you want to change this, you can configure the <code>previewNamingStrategy</code> property to one of the following values:</p> <ul> <li><code>suffix</code>: Previews should have <code>Preview</code> as suffix.</li> <li><code>prefix</code>: Previews should have <code>Preview</code> as prefix.</li> <li><code>anywhere</code>: Previews should contain <code>Preview</code> in their names.</li> </ul> <p> compose:preview-naming ktlint  PreviewNaming detekt</p>"}]}