{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Overview","text":"<p>Compose Rules is a set of custom ktlint / detekt rules to ensure that your composables don't fall into common pitfalls that might be easy to miss in code reviews.</p>"},{"location":"#why","title":"Why","text":"<p>It can be challenging for big teams to adopt Compose, particularly because not everyone starts at the same time or with the same patterns. We created these static checks to ease that pain.</p> <p>Compose has lots of superpowers but also has a bunch of footguns to be aware of, as seen in this Twitter thread.</p> <p>This is where static checks come in. We want to detect as many potential issues as possible, as early as possible\u2014ideally before code review. Similar to other static analysis libraries, we hope this fosters a \"don't shoot the messenger\" philosophy and healthy Compose adoption.</p>"},{"location":"#using-with-ktlint","title":"Using with ktlint","text":"<p>You can refer to the Using with ktlint documentation.</p>"},{"location":"#using-with-detekt","title":"Using with detekt","text":"<p>You can refer to the Using with detekt documentation.</p>"},{"location":"detekt/","title":"Using with detekt","text":"<p>Add the dependency using <code>detektPlugins</code> in your detekt Gradle Plugin configuration:</p> <pre><code>dependencies {\n    detektPlugins \"io.nlopez.compose.rules:detekt:&lt;VERSION&gt;\"\n}\n</code></pre>"},{"location":"detekt/#supported-versions-matrix","title":"Supported versions matrix","text":"Version Detekt version Kotlin (Syntax) 0.5.6+ 2.0.0-alpha.2 2.3.0 0.5.0+ 2.0.0-alpha.1 2.2.21 0.4.23 1.23.8 2.0.21 0.4.16+ 1.23.7 2.0.21 0.4.12+ 1.23.7 2.0.20 0.4.2+ 1.23.6 2.0.0 0.3.13+ 1.23.6 1.9.23 <p>Older version support can be found in the release notes.</p>"},{"location":"detekt/#using-with-detekt-cli-detekt-ide-plugin","title":"Using with detekt CLI / detekt IDE plugin","text":"<p>The releases page contains an uber jar for each version that can be used with the detekt CLI:</p> <pre><code>detekt -p detekt-compose-&lt;VERSION&gt;-all.jar -c your/config/detekt.yml\n</code></pre> <p>For the IDE plugin, add the uber jar to the custom plugins list and enable the rules in the yml config.</p>"},{"location":"detekt/#enabling-rules","title":"Enabling rules","text":"<p>Enable the rules in your <code>detekt.yml</code> configuration file:</p> <pre><code>Compose:\n  ComposableAnnotationNaming:\n    active: true\n  ComposableNaming:\n    active: true\n    # -- You can optionally disable the checks in this rule for regex matches against the composable name (e.g. molecule presenters)\n    # allowedComposableFunctionNames: .*Presenter,.*MoleculePresenter\n  ComposableParamOrder:\n    active: true\n    # -- You can optionally have a list of types to be treated as lambdas (e.g. typedefs or fun interfaces not picked up automatically)\n    # treatAsLambda: MyLambdaType\n    # -- You can optionally have a list of types to be treated as composable lambdas (e.g. typedefs or fun interfaces not picked up automatically).\n    # -- The difference with treatAsLambda is that those need `@Composable` MyLambdaType in the definition, while these won't.\n    # treatAsComposableLambda: MyComposableLambdaType\n  CompositionLocalAllowlist:\n    active: true\n    # -- You can optionally define a list of CompositionLocals that are allowed here\n    # allowedCompositionLocals: LocalSomething,LocalSomethingElse\n  CompositionLocalNaming:\n    active: true\n  ContentEmitterReturningValues:\n    active: true\n    # -- You can optionally add your own composables here\n    # contentEmitters: MyComposable,MyOtherComposable\n  ContentTrailingLambda:\n    active: true\n    # -- You can optionally have a list of types to be treated as lambdas (e.g. typedefs or fun interfaces not picked up automatically)\n    # treatAsLambda: MyLambdaType\n    # -- You can optionally have a list of types to be treated as composable lambdas (e.g. typedefs or fun interfaces not picked up automatically).\n    # -- The difference with treatAsLambda is that those need `@Composable` MyLambdaType in the definition, while these won't.\n    # treatAsComposableLambda: MyComposableLambdaType\n  ContentSlotReused:\n    active: true\n    # -- You can optionally have a list of types to be treated as composable lambdas (e.g. typedefs or fun interfaces not picked up automatically).\n    # -- The difference with treatAsLambda is that those need `@Composable` MyLambdaType in the definition, while these won't.\n    # treatAsComposableLambda: MyComposableLambdaType\n  DefaultsVisibility:\n    active: true\n  LambdaParameterEventTrailing:\n    active: true\n    # -- You can optionally add your own composables here\n    # contentEmitters: MyComposable,MyOtherComposable\n    # -- You can add composables here that you don't want to count as content emitters (e.g. custom dialogs or modals)\n    # contentEmittersDenylist: MyNonEmitterComposable\n  LambdaParameterInRestartableEffect:\n    active: true\n    # -- You can optionally have a list of types to be treated as lambdas (e.g. typedefs or fun interfaces not picked up automatically)\n    # treatAsLambda: MyLambdaType\n  Material2:\n    active: false # Opt-in, disabled by default. Turn on if you want to disallow Material 2 usages.\n    # -- You can optionally allow parts of it, if you are in the middle of a migration.\n    # allowedFromM2: icons.Icons,TopAppBar\n  ModifierClickableOrder:\n    active: true\n    # -- You can optionally add your own Modifier types\n    # customModifiers: BananaModifier,PotatoModifier\n  ModifierComposed:\n    active: true\n    # -- You can optionally add your own Modifier types\n    # customModifiers: BananaModifier,PotatoModifier\n  ModifierMissing:\n    active: true\n    # -- You can optionally control the visibility of which composables to check for here\n    # -- Possible values are: `only_public`, `public_and_internal` and `all` (default is `only_public`)\n    # checkModifiersForVisibility: only_public\n    # -- You can optionally add your own Modifier types\n    # customModifiers: BananaModifier,PotatoModifier\n    # -- You can suppress this check in functions annotated with these annotations\n    # ignoreAnnotated: ['Potato', 'Banana']\n  ModifierNaming:\n    active: true\n    # -- You can optionally add your own Modifier types\n    # customModifiers: BananaModifier,PotatoModifier\n  ModifierNotUsedAtRoot:\n    active: true\n    # -- You can optionally add your own composables here\n    # contentEmitters: MyComposable,MyOtherComposable\n    # -- You can optionally add your own Modifier types\n    # customModifiers: BananaModifier,PotatoModifier\n  ModifierReused:\n    active: true\n    # -- You can optionally add your own Modifier types\n    # customModifiers: BananaModifier,PotatoModifier\n  ModifierWithoutDefault:\n    active: true\n  MultipleEmitters:\n    active: true\n    # -- You can optionally add your own composables here that will count as content emitters\n    # contentEmitters: MyComposable,MyOtherComposable\n    # -- You can add composables here that you don't want to count as content emitters (e.g. custom dialogs or modals)\n    # contentEmittersDenylist: MyNonEmitterComposable\n  MutableParams:\n    active: true\n  MutableStateAutoboxing:\n    active: true\n  MutableStateParam:\n    active: true\n  ParameterNaming:\n    active: true\n    # -- You can optionally have a list of types to be treated as lambdas (e.g. typedefs or fun interfaces not picked up automatically)\n    # treatAsLambda: MyLambdaType\n    # -- You can optionally add your allowed lambda names (e.g., usages from the past found in the official Compose code)\n    # allowedLambdaParameterNames: onSizeChanged, onGloballyPositioned\n  PreviewAnnotationNaming:\n    active: true\n  PreviewNaming:\n    active: false # Opt-in, disabled by default.\n    # -- You can optionally configure the naming strategy for previews.\n    # -- Possible values are: `suffix`, `prefix`, `anywhere`. By default, it will be `suffix`.\n    # previewNamingStrategy: suffix\n  PreviewPublic:\n    active: true\n  RememberContentMissing:\n    active: true\n  RememberMissing:\n    active: true\n  StateParam:\n    active: true\n  UnstableCollections:\n    active: false # Opt-in, disabled by default. Turn on if you want to enforce this (e.g. you have strong skipping disabled)\n  ViewModelForwarding:\n    active: true\n    # -- You can optionally use this rule on things other than types ending in \"ViewModel\" or \"Presenter\" (which are the defaults). You can add your own via a regex here:\n    # allowedStateHolderNames: .*ViewModel,.*Presenter\n    # -- You can optionally add an allowlist for Composable names that won't be affected by this rule\n    # allowedForwarding: .*Content,.*FancyStuff\n    # -- You can optionally add an allowlist for ViewModel/StateHolder names that won't be affected by this rule\n    # allowedForwardingOfTypes: PotatoViewModel,(Apple|Banana)ViewModel,.*FancyViewModel\n  ViewModelInjection:\n    active: true\n    # -- You can optionally add your own ViewModel factories here\n    # viewModelFactories: hiltViewModel,potatoViewModel\n</code></pre>"},{"location":"detekt/#disabling-a-specific-rule","title":"Disabling a specific rule","text":"<p>Follow the detekt documentation to suppress specific rules. For example:</p> <pre><code>@Suppress(\"ComposableNaming\")\n@Composable\nfun myNameIsWrong() { }\n</code></pre> <p>You can also disable rules altogether by changing the <code>active: true</code> to <code>active: false</code> in your detekt configuration yml file.</p>"},{"location":"ktlint/","title":"Using with ktlint","text":""},{"location":"ktlint/#using-with-kotlinter","title":"Using with Kotlinter","text":"<p>If using kotlinter, you can specify the dependency on this set of rules by using the <code>buildscript</code> classpath.</p> <pre><code>buildscript {\n    dependencies {\n        classpath \"io.nlopez.compose.rules:ktlint:&lt;version&gt;\"\n    }\n}\n</code></pre>"},{"location":"ktlint/#using-with-ktlint-gradle","title":"Using with ktlint-gradle","text":"<p>Note: You need at least version 11.1.0 of this plugin.</p> <p>If using ktlint-gradle, you can specify the dependency on this set of rules by using the <code>ktlintRuleset</code>.</p> <pre><code>dependencies {\n    ktlintRuleset \"io.nlopez.compose.rules:ktlint:&lt;VERSION&gt;\"\n}\n</code></pre>"},{"location":"ktlint/#using-with-spotless","title":"Using with spotless","text":"<p>See Spotless Ktlint Integration.</p>"},{"location":"ktlint/#using-with-ktlint-cli-or-the-ktlint-intellij-plugin","title":"Using with ktlint CLI or the ktlint IntelliJ plugin","text":"<p>The releases page contains an uber jar for each version. Look for files with the <code>-all.jar</code> suffix.</p> <p>To use with ktlint CLI: <pre><code>ktlint -R ktlint-compose-&lt;VERSION&gt;-all.jar\n</code></pre></p> <p>You can also use this uber jar with the ktlint IntelliJ plugin, provided the rules are compiled against the same ktlint version. Configure the custom ruleset in the plugin's preferences.</p>"},{"location":"ktlint/#supported-versions-matrix","title":"Supported versions matrix","text":"Version Ktlint version Kotlin (Syntax) 0.4.28+ 1.8.0 2.2.21 0.4.26+ 1.7.1 2.2.0 0.4.25 1.7.0 2.2.0 0.4.24 1.6.0 2.1.21 0.4.23 1.5.0 2.1.0 0.4.18+ 1.4.1 2.0.21 0.4.17 1.4.0 2.0.21 0.4.12+ 1.3.1 2.0.20 0.4.6+ 1.3.1 2.0.0 0.4.5 1.3.0 2.0.0 0.3.12+ 1.2.1 1.9.23 0.3.9+ 1.1.1 1.9.22 <p>Older version support can be found in the release notes.</p>"},{"location":"ktlint/#configuring-rules","title":"Configuring rules","text":""},{"location":"ktlint/#providing-custom-content-emitters","title":"Providing custom content emitters","text":"<p>Some rules (<code>compose:content-emitter-returning-values-check</code>, <code>compose:modifier-not-used-at-root</code>, <code>compose:multiple-emitters-check</code>) use a predefined list of composables that emit content. You can add your own (e.g., design system composables) in your <code>.editorconfig</code> file:</p> <pre><code>[*.{kt,kts}]\ncompose_content_emitters = MyComposable,MyOtherComposable\n</code></pre>"},{"location":"ktlint/#providing-exceptions-to-content-emitters","title":"Providing exceptions to content emitters","text":"<p>Sometimes a composable emits content in a different window (like a dialog or modal) and shouldn't count toward the <code>compose:multiple-emitters-check</code> rule. Use the denylist to exclude these:</p> <pre><code>[*.{kt,kts}]\ncompose_content_emitters_denylist = MyModalComposable,MyDialogComposable\n</code></pre>"},{"location":"ktlint/#providing-custom-viewmodel-factories","title":"Providing custom ViewModel factories","text":"<p>The <code>vm-injection-check</code> rule checks common ViewModel factories (<code>viewModel</code>, <code>hiltViewModel</code>, etc.). Add your own:</p> <pre><code>[*.{kt,kts}]\ncompose_view_model_factories = myViewModel,potatoViewModel\n</code></pre>"},{"location":"ktlint/#providing-a-list-of-allowed-compositionlocals","title":"Providing a list of allowed <code>CompositionLocal</code>s","text":"<p>For <code>compositionlocal-allowlist</code> rule you can define a list of <code>CompositionLocal</code>s that are allowed in your codebase.</p> <pre><code>[*.{kt,kts}]\ncompose_allowed_composition_locals = LocalSomething,LocalSomethingElse\n</code></pre>"},{"location":"ktlint/#providing-a-list-of-allowed-composable-lambda-names","title":"Providing a list of allowed Composable Lambda Names","text":"<p>For <code>parameter-naming</code> rule you can define a list of parameter names for function types that are allowed in your codebase. For example, usages from the past found in the official Compose code.</p> <pre><code>[*.{kt,kts}]\ncompose_allowed_lambda_parameter_names = onSizeChanged,onGloballyPositioned\n</code></pre>"},{"location":"ktlint/#ignore-annotated-functions-with-specific-annotations-for-missing-modifier-checks","title":"Ignore annotated functions with specific annotations for missing Modifier checks","text":"<p>In the <code>modifier-missing-check</code> rule, you can define a list of annotations that, if present, will make it so the function is exempt from this rule.</p> <pre><code>[*.{kt,kts}]\ncompose_modifier_missing_ignore_annotated = Potato,Banana\n</code></pre>"},{"location":"ktlint/#allowing-matching-function-names","title":"Allowing matching function names","text":"<p>The <code>naming-check</code> rule requires composables that return a value to be lowercased. To allow certain patterns, configure a comma-separated list of regexes:</p> <pre><code>[*.{kt,kts}]\ncompose_allowed_composable_function_names = .*Presenter,.*SomethingElse\n</code></pre>"},{"location":"ktlint/#allowing-custom-state-holder-names","title":"Allowing custom state holder names","text":"<p>The <code>vm-forwarding-check</code> rule treats classes ending in \"ViewModel\" or \"Presenter\" as state holders by default. Add custom patterns via regexes:</p> <pre><code>[*.{kt,kts}]\ncompose_allowed_state_holder_names = .*ViewModel,.*Presenter,.*Component,.*SomethingElse\n</code></pre>"},{"location":"ktlint/#allowlist-for-composable-names-that-arent-affected-by-the-viewmodelforwarding-rule","title":"Allowlist for composable names that aren't affected by the ViewModelForwarding rule","text":"<p>The <code>vm-forwarding-check</code> catches ViewModels/state holders relayed to other composables. To allow specific composable names:</p> <pre><code>[*.{kt,kts}]\ncompose_allowed_forwarding = .*Content,.*SomethingElse\n</code></pre>"},{"location":"ktlint/#allowlist-for-viewmodelstate-holder-names-that-arent-affected-by-the-viewmodelforwarding-rule","title":"Allowlist for ViewModel/state holder names that aren't affected by the ViewModelForwarding rule","text":"<p>To allow specific ViewModel/state holder types to be forwarded:</p> <pre><code>[*.{kt,kts}]\ncompose_allowed_forwarding_of_types = .*MyViewModel,PotatoViewModel\n</code></pre>"},{"location":"ktlint/#configure-the-visibility-of-the-composables-where-to-check-for-missing-modifiers","title":"Configure the visibility of the composables where to check for missing modifiers","text":"<p>The <code>modifier-missing-check</code> rule will, by default, only check public composables for missing modifiers. To also check internal or all composables, configure it in your <code>.editorconfig</code> file:</p> <pre><code>[*.{kt,kts}]\ncompose_check_modifiers_for_visibility = only_public\n</code></pre> <p>Possible values are:</p> <ul> <li><code>only_public</code>: (default) Will check for missing modifiers only for public composables.</li> <li><code>public_and_internal</code>: Will check for missing modifiers in both public and internal composables.</li> <li><code>all</code>: Will check for missing modifiers in all composables.</li> </ul>"},{"location":"ktlint/#configure-custom-modifier-names","title":"Configure custom Modifier names","text":"<p>Most modifier-related rules identify modifiers by type (<code>Modifier</code> or <code>GlanceModifier</code>). If your library has a custom Modifier type, you can add it so the same rules apply:</p> <pre><code>[*.{kt,kts}]\ncompose_custom_modifiers = BananaModifier,PotatoModifier\n</code></pre>"},{"location":"ktlint/#configure-types-to-treat-as-lambdas-eg-for-paramorder-check","title":"Configure types to treat as lambdas (e.g. for ParamOrder check)","text":"<p>The <code>param-order-check</code> rule identifies trailing lambdas automatically. For typedefs or functional interfaces that should be treated as lambdas, add hints:</p> <pre><code>[*.{kt,kts}]\ncompose_treat_as_lambda = MyLambdaType,MyOtherLambdaType\n</code></pre>"},{"location":"ktlint/#configure-types-to-treat-as-composable-lambdas-eg-for-contenttrailinglambda-check","title":"Configure types to treat as composable lambdas (e.g. for ContentTrailingLambda check)","text":"<p>The <code>content-trailing-lambda</code> rule identifies <code>@Composable</code> trailing lambdas automatically. For typedefs or functional interfaces that should be treated as composable lambdas:</p> <pre><code>[*.{kt,kts}]\ncompose_treat_as_composable_lambda = MyLambdaComposableType,MyOtherComposableLambdaType\n</code></pre>"},{"location":"ktlint/#enabling-the-material-2-detector","title":"Enabling the Material 2 detector","text":"<p>The <code>material-two</code> rule flags Material 2 API usage. Disabled by default; enable it in your <code>.editorconfig</code> file:</p> <pre><code>[*.{kt,kts}]\ncompose_disallow_material2 = true\n</code></pre> <p>You can also allow specific Material 2 APIs during migration. For example, to allow filled icons and <code>Button</code>:</p> <pre><code>[*.{kt,kts}]\ncompose_disallow_material2 = true\ncompose_allowed_from_m2 = icons.filled,Button\n</code></pre>"},{"location":"ktlint/#enabling-the-unstable-collections-detector","title":"Enabling the unstable collections detector","text":"<p>The <code>unstable-collections</code> rule flags unstable collection usage (List/Set/Map). Disabled by default:</p> <pre><code>[*.{kt,kts}]\ncompose_disallow_unstable_collections = true\n</code></pre>"},{"location":"ktlint/#enabling-and-configuring-the-preview-naming-detector","title":"Enabling and configuring the preview naming detector","text":"<p>To enforce a naming strategy for previews, enable the rule and configure the strategy:</p> <pre><code>[*.{kt,kts}]\ncompose_preview_naming_enabled = true\ncompose_preview_naming_strategy = suffix\n</code></pre> <p>Possible values of <code>compose_preview_naming_strategy</code> are:</p> <ul> <li><code>suffix</code>: Previews should have <code>Preview</code> as suffix.</li> <li><code>prefix</code>: Previews should have <code>Preview</code> as prefix.</li> <li><code>anywhere</code>: Previews should contain <code>Preview</code> in their names.</li> </ul>"},{"location":"ktlint/#disable-standardfunction-naming-rule-for-composable","title":"Disable <code>standard:function-naming</code> rule for Composable","text":"<p>Composable function names start with uppercase, which causes ktlint's <code>standard:function-naming</code> rule to report violations. Configure it to ignore Composable functions:</p> <pre><code>[*.{kt,kts}]\nktlint_function_naming_ignore_when_annotated_with = Composable\n</code></pre>"},{"location":"ktlint/#disabling-a-specific-rule","title":"Disabling a specific rule","text":"<p>To disable a rule you have to follow the instructions from the ktlint documentation, and use the id of the rule you want to disable with the <code>compose</code> tag.</p> <p>For example, to disable the <code>naming-check</code> rule, the tag you'll need to disable is <code>ktlint:compose:naming-check</code>.</p> <pre><code>    @Suppress(\"ktlint:compose:naming-check\")\n    fun YourComposableHere() { ... }\n</code></pre>"},{"location":"rules/","title":"Rules","text":""},{"location":"rules/#state","title":"State","text":""},{"location":"rules/#hoist-all-the-things","title":"Hoist all the things","text":"<p>Compose is built upon the idea of unidirectional data flow: data/state flows down, and events fire up. To achieve this, Compose advocates for hoisting state upwards, making most composable functions stateless. This has many benefits, including easier testing.</p> <pre><code>flowchart TB\n    subgraph Parent[Parent Composable]\n        S[State]\n    end\n    subgraph Child[Child Composable]\n        U[UI]\n    end\n    S --&gt;|state flows down| U\n    U --&gt;|events fire up| S</code></pre> <p>In practice, watch out for these common issues:</p> <ul> <li>Do not pass ViewModels (or objects from DI) down.</li> <li>Do not pass <code>MutableState&lt;T&gt;</code> instances down.</li> <li>Do not pass <code>State&lt;T&gt;</code> instances down.</li> <li>Do not pass inherently mutable types that cannot be observed.</li> </ul> <p>Instead, pass the relevant data to the function and use lambdas for callbacks.</p> <p>More information: State and Jetpack Compose</p> <p> compose:vm-forwarding-check ktlint  ViewModelForwarding detekt</p>"},{"location":"rules/#state-should-be-remembered-in-composables","title":"State should be remembered in composables","text":"<p>Be careful when using <code>mutableStateOf</code> (or any of the other <code>State&lt;T&gt;</code> builders) to make sure that you <code>remember</code> the instance. If you don't <code>remember</code> the state instance, a new state instance will be created when the function is recomposed.</p> <p> compose:remember-missing-check ktlint  RememberMissing detekt</p>"},{"location":"rules/#use-mutablestateof-type-specific-variants-when-possible","title":"Use mutableStateOf type-specific variants when possible","text":"<p>Compose provides type-specific state variants that avoid autoboxing on JVM platforms, making them more memory efficient. Use these instead of <code>mutableStateOf</code> when working with primitives or primitive collections.</p> <p>Primitives:</p> Instead of Use <code>mutableStateOf&lt;Int&gt;</code> <code>mutableIntStateOf</code> <code>mutableStateOf&lt;Long&gt;</code> <code>mutableLongStateOf</code> <code>mutableStateOf&lt;Float&gt;</code> <code>mutableFloatStateOf</code> <code>mutableStateOf&lt;Double&gt;</code> <code>mutableDoubleStateOf</code> <p>Primitive Lists:</p> Instead of Use <code>mutableStateOf(List&lt;Int&gt;)</code> <code>mutableIntListOf</code> <code>mutableStateOf(List&lt;Long&gt;)</code> <code>mutableLongListOf</code> <code>mutableStateOf(List&lt;Float&gt;)</code> <code>mutableFloatListOf</code> <p>Primitive Sets:</p> Instead of Use <code>mutableStateOf(Set&lt;Int&gt;)</code> <code>mutableIntSetOf</code> <code>mutableStateOf(Set&lt;Long&gt;)</code> <code>mutableLongSetOf</code> <code>mutableStateOf(Set&lt;Float&gt;)</code> <code>mutableFloatSetOf</code> <p>Primitive Maps:</p> Instead of Use <code>mutableStateOf(Map&lt;Int, Int&gt;)</code> <code>mutableIntIntMapOf</code> <code>mutableStateOf(Map&lt;Int, Long&gt;)</code> <code>mutableIntLongMapOf</code> <code>mutableStateOf(Map&lt;Int, Float&gt;)</code> <code>mutableIntFloatMapOf</code> <code>mutableStateOf(Map&lt;Long, Int&gt;)</code> <code>mutableLongIntMapOf</code> <code>mutableStateOf(Map&lt;Long, Long&gt;)</code> <code>mutableLongLongMapOf</code> <code>mutableStateOf(Map&lt;Long, Float&gt;)</code> <code>mutableLongFloatMapOf</code> <code>mutableStateOf(Map&lt;Float, Int&gt;)</code> <code>mutableFloatIntMapOf</code> <code>mutableStateOf(Map&lt;Float, Long&gt;)</code> <code>mutableFloatLongMapOf</code> <code>mutableStateOf(Map&lt;Float, Float&gt;)</code> <code>mutableFloatFloatMapOf</code> <p>The collection variants also apply to <code>PersistentList</code>, <code>ImmutableList</code>, <code>PersistentSet</code>, <code>ImmutableSet</code>, <code>PersistentMap</code>, and <code>ImmutableMap</code>.</p> <p> compose:mutable-state-autoboxing ktlint  MutableStateAutoboxing detekt</p>"},{"location":"rules/#composables","title":"Composables","text":""},{"location":"rules/#do-not-use-inherently-mutable-types-as-parameters","title":"Do not use inherently mutable types as parameters","text":"<p>This follows from the \"Hoist all the things\" rule above. While it might be tempting to pass mutable state down to a function, this is an anti-pattern that breaks unidirectional data flow. Mutations are events that should be modeled as lambda callbacks in the function API.</p> <p>The main issue is that mutable objects often don't trigger recomposition. Without recomposition, your composables won't automatically update to reflect the new value.</p> <p>Common examples include passing <code>ArrayList&lt;T&gt;</code> or <code>ViewModel</code>, but this applies to any mutable type.</p> <p> compose:mutable-params-check ktlint  MutableParams detekt</p>"},{"location":"rules/#do-not-use-mutablestate-as-a-parameter","title":"Do not use MutableState as a parameter","text":"<p>Using <code>MutableState&lt;T&gt;</code> as a parameter promotes shared ownership of state between a component and its caller.</p> <p>Instead, make the component stateless and let the caller handle state changes. If the component needs to mutate the parent's property, consider creating a <code>ComponentState</code> class with a domain-specific field backed by <code>mutableStateOf(...)</code>.</p> <p>When a component accepts <code>MutableState</code> as a parameter, it can change it at will. This splits state ownership, and the caller loses control over how and when the state changes.</p> <p>More info: Compose API guidelines</p> <p> compose:mutable-state-param-check ktlint  MutableStateParam detekt</p>"},{"location":"rules/#do-not-use-state-as-a-parameter","title":"Do not use State as a parameter","text":"<p>Using <code>State&lt;T&gt;</code> as a parameter encourages passing state holders instead of values, which makes components harder to reason about and test.</p> <p>Instead, pass the snapshot state value and expose callbacks to report changes.</p> <pre><code>// \u274c Passing State down\n@Composable\nfun Counter(label: String, count: State&lt;Int&gt;) { /* ... */ }\n\n// \u2705 Pass values and events instead\n@Composable\nfun Counter(label: String, count: Int, onCountChange: (Int) -&gt; Unit) { /* ... */ }\n</code></pre> <p>More info: Compose API guidelines</p> <p> compose:state-param-check ktlint  StateParam detekt</p>"},{"location":"rules/#be-mindful-of-effect-keys","title":"Be mindful of effect keys","text":"<p>In Compose, effects like <code>LaunchedEffect</code>, <code>produceState</code>, and <code>DisposableEffect</code> use keys to control when they restart:</p> <pre><code>EffectName(key1, key2, key3, ...) { block }\n</code></pre> <p>Using the wrong keys can cause:</p> <ul> <li>Bugs if the effect restarts less often than needed.</li> <li>Inefficiency if the effect restarts more often than necessary.</li> </ul> <p>To ensure proper behavior:</p> <ul> <li>Include variables used in the effect block as key parameters.</li> <li>Use <code>rememberUpdatedState</code> to prevent unnecessary restarts when you don't want to restart the effect (e.g., inside a flow collector).</li> <li>Variables that never change (via <code>remember</code> with no keys) don't need to be passed as effect keys.</li> </ul> <p>Here are some examples:</p> <pre><code>// \u274c onClick changes, but the effect won't be pointing to the right one!\n@Composable\nfun MyComposable(onClick: () -&gt; Unit) {\n    LaunchedEffect(Unit) {\n        delay(10.seconds) // something that takes time, a flow collection, etc\n        onClick()\n    }\n    // ...\n}\n// \u2705 onClick changes and the LaunchedEffect won't be rebuilt -- but will point at the correct onClick!\n@Composable\nfun MyComposable(onClick: () -&gt; Unit) {\n    val latestOnClick by rememberUpdatedState(onClick)\n    LaunchedEffect(Unit) {\n        delay(10.seconds) // something that takes time, a flow collection, etc\n        latestOnClick()\n    }\n    // ...\n}\n// \u2705 _If we don't care about rebuilding the effect_, we can also use the parameter as key\n@Composable\nfun MyComposable(onClick: () -&gt; Unit) {\n    // This effect will be rebuilt every time onClick changes, so it will always point to the latest one.\n    LaunchedEffect(onClick) {\n        delay(10.seconds) // something that takes time, a flow collection, etc\n        onClick()\n    }\n}\n</code></pre> <p>More info: Restarting effects and rememberUpdatedState</p> <p> compose:lambda-param-in-effect ktlint  LambdaParameterInRestartableEffect detekt</p>"},{"location":"rules/#do-not-emit-content-and-return-a-result","title":"Do not emit content and return a result","text":"<p>Composable functions should either emit layout content or return a value, but not both.</p> <p>If a composable needs to offer additional control surfaces to its caller, those should be provided as parameters.</p> <p>More info: Compose API guidelines</p> <p> compose:content-emitter-returning-values-check ktlint  ContentEmitterReturningValues detekt</p> <p>Note: To add your custom composables so they are used in this rule (things like your design system composables), you can add <code>composeEmitters</code> to this rule config in Detekt, or <code>compose_emitters</code> to your .editorconfig in ktlint.</p>"},{"location":"rules/#do-not-emit-multiple-pieces-of-content","title":"Do not emit multiple pieces of content","text":"<p>A composable function should emit zero or one layout nodes. Each composable should be cohesive and not depend on its call site.</p> <p>In this example, <code>InnerContent()</code> emits multiple layout nodes and assumes it will be called from a <code>Column</code>:</p> <pre><code>// This will render:\n// &lt;text&gt;\n// &lt;image&gt;\n// &lt;button&gt;\nColumn {\n    InnerContent()\n}\n\n// \u274c Unclear UI, as we emit multiple pieces of content at the same time\n@Composable\nprivate fun InnerContent() {\n    Text(...)\n    Image(...)\n    Button(...)\n}\n</code></pre> <p>However, <code>InnerContent</code> could just as easily be called from a <code>Row</code> or <code>Box</code>, which would break these assumptions:</p> <pre><code>// \u274c This will render: &lt;text&gt;&lt;image&gt;&lt;button&gt;\nRow {\n    InnerContent()\n}\n// \u274c This will render all elements on top of each other.\nBox {\n    InnerContent()\n}\n</code></pre> <p>Instead, InnerContent should be cohesive and emit a single layout node itself:</p> <p><pre><code>// \u2705\n@Composable\nprivate fun InnerContent() {\n    Column {\n        Text(...)\n        Image(...)\n        Button(...)\n    }\n}\n</code></pre> Unlike the View system, nesting layouts in Compose has minimal performance cost, so don't sacrifice correctness to minimize UI layers.</p> <p>There is one exception: when the function is defined as an extension function of an appropriate scope: <pre><code>// \u2705\n@Composable\nprivate fun ColumnScope.InnerContent() {\n    Text(...)\n    Image(...)\n    Button(...)\n}\n</code></pre> This effectively ties the function to be called from a Column, but is still not recommended (although permitted).</p> <p> compose:multiple-emitters-check ktlint  MultipleEmitters detekt</p> <p>Note: To add your custom composables so they are used in this rule (things like your design system composables), you can add <code>composeEmitters</code> to this rule config in Detekt, or <code>compose_emitters</code> to your .editorconfig in ktlint.</p>"},{"location":"rules/#slots-for-main-content-should-be-the-trailing-lambda","title":"Slots for main content should be the trailing lambda","text":"<p>Content slots (typically <code>content: @Composable () -&gt; Unit</code> or nullable variants) should always be the last parameter so they can be written as a trailing lambda. This makes the UI flow more natural and easier to read.</p> <pre><code>// \u274c\n@Composable\nfun Avatar(content: @Composable () -&gt; Unit, subtitle: String, modifier: Modifier = Modifier) { ... }\n\n// \u2705 The usage of the main content as a trailing lambda is more natural\n@Composable\nfun Avatar(subtitle: String, modifier: Modifier = Modifier, content: @Composable () -&gt; Unit) { ... }\n\n@Composable\nfun Profile(user: User, modifier: Modifier = Modifier) {\n    Column(modifier) {\n        Avatar(subtitle = user.name) {\n            AsyncImage(url = user.avatarUrl)\n        }\n    }\n}\n</code></pre> <p> compose:content-trailing-lambda ktlint  ContentTrailingLambda detekt</p>"},{"location":"rules/#content-slots-should-not-be-reused-in-branching-code","title":"Content slots should not be reused in branching code","text":"<p>Content slots should not be disposed and recomposed when the parent composable changes due to branching code.</p> <p>Ensure that the lifecycle of slot composables matches the lifecycle of the parent composable or is tied to visibility within the viewport.</p> <p>To ensure proper behavior:</p> <ul> <li>Use <code>remember { movableContentOf { ... } }</code> to make sure the content is preserved correctly; or</li> <li>Create a custom layout where the internal state of the slot is preserved.</li> </ul> <pre><code>// \u274c\n@Composable\nfun Avatar(user: User, content: @Composable () -&gt; Unit) {\n    if (user.isFollower) {\n        content()\n    } else {\n        content()\n    }\n}\n\n// \u2705\n@Composable\nfun Avatar(user: User, content: @Composable () -&gt; Unit) {\n    val content = remember { movableContentOf { content() } }\n    if (user.isFollower) {\n        content()\n    } else {\n        content()\n    }\n}\n</code></pre> <p>More information: Lifecycle expectations for slot parameters</p> <p> compose:content-slot-reused ktlint  ContentSlotReused detekt</p>"},{"location":"rules/#avoid-trailing-lambdas-for-event-handlers","title":"Avoid trailing lambdas for event handlers","text":"<p>In Compose, trailing lambdas are typically used for content slots. To avoid confusion, event lambdas (e.g., <code>onClick</code>, <code>onValueChange</code>) should not be placed in the trailing position.</p> <p>Recommendations:</p> <ul> <li>Required event lambdas: Place them before the <code>Modifier</code> parameter to clearly distinguish them from content slots.</li> <li>Optional event lambdas: Avoid placing them as the last parameter when possible.</li> </ul> <pre><code>// \u274c Using an event lambda (like onClick) as the trailing lambda when in a composable makes it error prone and awkward to read\n@Composable\nfun MyButton(modifier: Modifier = Modifier, onClick: () -&gt; Unit) { /* ... */ }\n\n@Composable\nfun SomeUI(modifier: Modifier = Modifier) {\n    MyButton {\n        // This is an onClick, but by reading it people would assume it's a content slot\n    }\n}\n\n// \u2705 By moving the event lambda to be before Modifier, we avoid confusion\n@Composable\nfun MyBetterButton(onClick: () -&gt; Unit, modifier: Modifier = Modifier) { /* ... */ }\n\n@Composable\nfun SomeUI(modifier: Modifier = Modifier) {\n    MyBetterButton(\n        onClick = {\n            // Now this param is straightforward to understand\n        },\n    )\n}\n</code></pre> <p> compose:lambda-param-event-trailing ktlint  LambdaParameterEventTrailing detekt</p>"},{"location":"rules/#naming-compositionlocals-properly","title":"Naming CompositionLocals properly","text":"<p><code>CompositionLocal</code>s should be named with <code>Local</code> as a prefix, followed by a descriptive noun (e.g., <code>LocalTheme</code>, <code>LocalUser</code>). This makes implicit dependencies obvious and easy to identify.</p> <p>More information: Naming CompositionLocals</p> <p> compose:compositionlocal-naming ktlint  CompositionLocalNaming detekt</p>"},{"location":"rules/#naming-multipreview-annotations-properly","title":"Naming multipreview annotations properly","text":"<p>Multipreview annotations should use <code>Previews</code> as a prefix (e.g., <code>@PreviewsLightDark</code>). This ensures they are clearly identifiable as <code>@Preview</code> alternatives at their usage sites.</p> <p>More information: Multipreview annotations and Google's own predefined annotations</p> <p> compose:preview-annotation-naming ktlint  PreviewAnnotationNaming detekt</p>"},{"location":"rules/#naming-composable-functions-properly","title":"Naming @Composable functions properly","text":"<p>Composable functions that return <code>Unit</code> should start with an uppercase letter. They represent declarative UI entities and follow class naming conventions.</p> <p>Composable functions that return a value should start with a lowercase letter, following standard Kotlin Coding Conventions.</p> <p>More information: Naming Unit @Composable functions as entities and Naming @Composable functions that return values</p> <p> compose:naming-check ktlint  ComposableNaming detekt</p>"},{"location":"rules/#naming-composable-annotations-properly","title":"Naming Composable annotations properly","text":"<p>Custom Composable annotations (tagged with <code>@ComposableTargetMarker</code>) should have the <code>Composable</code> suffix (for example, <code>@GoogleMapComposable</code> or <code>@MosaicComposable</code>).</p> <p> compose:composable-annotation-naming ktlint  ComposableAnnotationNaming detekt</p>"},{"location":"rules/#ordering-composable-parameters-properly","title":"Ordering @Composable parameters properly","text":"<p>In Kotlin, required parameters should come first, followed by optional ones (those with default values). This minimizes the need to explicitly name arguments.</p> <p>The <code>modifier</code> parameter should be the first optional parameter, creating a consistent expectation that callers can always provide a modifier as the final positional parameter.</p> <p>If there is a <code>content</code> lambda, it should be used as a trailing lambda.</p> <ol> <li>Required parameters (no default values)</li> <li>Optional parameters (have default values)<ol> <li><code>modifier: Modifier = Modifier</code></li> <li>The rest of optional params</li> </ol> </li> <li>[Optionally] A trailing lambda. If there is a <code>content</code> slot, it should be it.</li> </ol> <pre><code>  flowchart LR\n    A[Required parameters] --&gt; B[Modifier, if any]\n    B --&gt; C[Optional parameters]\n    C --&gt; D[Optionally a trailing lambda, eg a content slot]</code></pre> <p>An example of the above could be this:</p> <pre><code>// \u2705\n@Composable\nfun Avatar(\n    imageUrl: String,               // Required parameters go first\n    contentDescription: String,\n    onClick: () -&gt; Unit,\n    modifier: Modifier = Modifier,  // Optional parameters, start with modifier\n    enabled: Boolean = true,        // Other optional parameters\n    loadingContent: @Composable (() -&gt; Unit)? = null,\n    errorContent: @Composable (() -&gt; Unit)? = null,\n    content: @Composable () -&gt; Unit, // A trailing lambda _can_ be last. Recommended for `content` slots.\n) { ... }\n</code></pre> <p>More information: Kotlin default arguments, Modifier docs and Elements accept and respect a Modifier parameter.</p> <p> compose:param-order-check ktlint  ComposableParamOrder detekt</p>"},{"location":"rules/#naming-parameters-properly","title":"Naming parameters properly","text":"<p>Event parameters in composable functions should follow the pattern <code>on</code> + verb in present tense, like <code>onClick</code> or <code>onTextChange</code>. For consistency, use present tense verbs.</p> <pre><code>// \u274c\n@Composable\nfun Avatar(onShown: () -&gt; Unit, onChanged: () -&gt; Unit) { /* ... */ }\n\n// \u2705\n@Composable\nfun Avatar(onShow: () -&gt; Unit, onChange: () -&gt; Unit) { /* ... */ }\n</code></pre> <p> compose:parameter-naming ktlint  ParameterNaming detekt</p>"},{"location":"rules/#movable-content-should-be-remembered","title":"Movable content should be remembered","text":"<p><code>movableContentOf</code> and <code>movableContentWithReceiverOf</code> must be used inside a <code>remember</code> function.</p> <p>These need to persist across compositions; if detached from the composition, they are immediately recycled.</p> <p> compose:remember-content-missing-check ktlint  RememberContentMissing detekt</p>"},{"location":"rules/#make-dependencies-explicit","title":"Make dependencies explicit","text":""},{"location":"rules/#viewmodels","title":"ViewModels","text":"<p>Composables should be explicit about their dependencies. Acquiring a ViewModel or DI instance inside the composable body makes the dependency implicit, which makes testing and reuse harder.</p> <p>Instead, inject dependencies as default parameter values.</p> <p><pre><code>// \u274c The VM dependency is implicit here.\n@Composable\nprivate fun MyComposable() {\n    val viewModel = viewModel&lt;MyViewModel&gt;()\n    // ...\n}\n</code></pre> With implicit dependencies, testing requires faking the <code>viewModel</code> internals.</p> <p>By passing dependencies as parameters with default values, you can easily provide test instances and make the function's dependencies clear in its signature.</p> <pre><code>// \u2705 The VM dependency is explicit\n@Composable\nprivate fun MyComposable(\n    viewModel: MyViewModel = viewModel(),\n) {\n    // ...\n}\n</code></pre> <p> compose:vm-injection-check ktlint  ViewModelInjection detekt</p>"},{"location":"rules/#compositionlocals","title":"<code>CompositionLocal</code>s","text":"<p><code>CompositionLocal</code> creates implicit dependencies that make composable behavior harder to understand. Callers must ensure every <code>CompositionLocal</code> is satisfied, which isn't apparent from the API.</p> <p>While there are legitimate use cases, this rule provides an allowlist for <code>CompositionLocal</code> names that shouldn't trigger warnings.</p> <p> compose:compositionlocal-allowlist ktlint  CompositionLocalAllowlist detekt</p> <p>Note: To add your custom <code>CompositionLocal</code> to your allowlist, you can add <code>allowedCompositionLocals</code> to this rule config in Detekt, or <code>compose_allowed_composition_locals</code> to your .editorconfig in ktlint.</p>"},{"location":"rules/#preview-composables-should-not-be-public","title":"Preview composables should not be public","text":"<p>Composable functions that exist solely for <code>@Preview</code> don't need public visibility since they won't be used in production UI. Make them <code>private</code> to prevent accidental usage.</p> <p> compose:preview-public-check ktlint  PreviewPublic detekt</p> <p>Note: If you are using Detekt, this may conflict with Detekt's UnusedPrivateMember rule. Be sure to set Detekt's ignoreAnnotated configuration to ['Preview'] for compatibility with this rule.</p>"},{"location":"rules/#modifiers","title":"Modifiers","text":""},{"location":"rules/#when-should-i-expose-modifier-parameters","title":"When should I expose modifier parameters?","text":"<p>Modifiers are central to Compose UI. They enable composition over inheritance by letting developers attach logic and behavior to layouts.</p> <p>They are especially important for public components, allowing callers to customize behavior and appearance.</p> <p>More info: Always provide a Modifier parameter</p> <p> compose:modifier-missing-check ktlint  ModifierMissing detekt</p>"},{"location":"rules/#modifier-order-matters","title":"Modifier order matters","text":"<p>The order of modifier functions is important. Each function transforms the Modifier returned by the previous one, so the sequence affects the final result:</p> <p><pre><code>// \u274c The UI will be off, as the pressed state ripple will extend beyond the intended shape\n@Composable\nfun MyCard(modifier: Modifier = Modifier) {\n    Column(\n        modifier\n            // Tapping on it does a ripple, the ripple is bound incorrectly to the composable\n            .clickable { /* TODO */ }\n            // Create rounded corners\n            .clip(shape = RoundedCornerShape(8.dp))\n            // Background with rounded corners\n            .background(color = backgroundColor, shape = RoundedCornerShape(8.dp))\n    ) {\n        // rest of the implementation\n    }\n}\n</code></pre> The entire area, including the clipped area and the clipped background, responds to clicks. This means that the ripple will fill it all, even the areas that we wanted to trim from the shape.</p> <p>We can address this by simply reordering the modifiers.</p> <pre><code>// \u2705 The UI will be now correct, as the pressed state ripple will have the same shape as the element\n@Composable\nfun MyCard(modifier: Modifier = Modifier) {\n    Column(\n        modifier\n            // Create rounded corners\n            .clip(shape = RoundedCornerShape(8.dp))\n            // Background with rounded corners\n            .background(color = backgroundColor, shape = RoundedCornerShape(8.dp))\n            // Tapping on it does a ripple, the ripple is bound correctly now to the composable\n            .clickable { /* TODO */ }\n    ) {\n        // rest of the implementation\n    }\n}\n</code></pre> <p>More info: Modifier documentation</p> <p> compose:modifier-clickable-order ktlint  ModifierClickableOrder detekt</p>"},{"location":"rules/#modifiers-should-be-used-at-the-top-most-layout-of-the-component","title":"Modifiers should be used at the top-most layout of the component","text":"<p>Apply the <code>modifier</code> parameter to the root layout as the first modifier in the chain. Since modifiers control external behavior and appearance, they must be applied at the top level. You can chain additional modifiers after the parameter if needed.</p> <p>More info: Compose Component API Guidelines</p> <p> compose:modifier-not-used-at-root ktlint  ModifierNotUsedAtRoot detekt</p>"},{"location":"rules/#dont-re-use-modifiers","title":"Don't re-use modifiers","text":"<p>A modifier parameter should only be used by a single layout node. Reusing it across multiple composables at different levels causes unexpected behavior.</p> <p>In this example, the modifier is passed to the root <code>Column</code> and also to each child:</p> <p><pre><code>// \u274c When changing `modifier` at the call site, it will affect the whole layout in unintended ways\n@Composable\nprivate fun InnerContent(modifier: Modifier = Modifier) {\n    Column(modifier) {\n        Text(modifier.clickable(), ...)\n        Image(modifier.size(), ...)\n        Button(modifier, ...)\n    }\n}\n</code></pre> Instead, apply the modifier only to the root <code>Column</code> and use fresh <code>Modifier</code> instances for descendants:</p> <pre><code>// \u2705 When changing `modifier` at the call site, it will only affect the external container of the UI\n@Composable\nprivate fun InnerContent(modifier: Modifier = Modifier) {\n    Column(modifier) {\n        Text(Modifier.clickable(), ...)\n        Image(Modifier.size(), ...)\n        Button(Modifier, ...)\n    }\n}\n</code></pre> <p> compose:modifier-reused-check ktlint  ModifierReused detekt</p>"},{"location":"rules/#modifiers-should-have-default-parameters","title":"Modifiers should have default parameters","text":"<p>The <code>modifier</code> parameter should default to <code>Modifier</code> and appear as the first optional parameter (after required parameters but before other optional ones). Any default modifiers the composable needs should be chained after the parameter in the implementation, not in the default value.</p> <p>More info: Modifier documentation</p> <p> compose:modifier-without-default-check ktlint  ModifierWithoutDefault detekt</p>"},{"location":"rules/#naming-modifiers-properly","title":"Naming modifiers properly","text":"<p>The main modifier parameter should be named <code>modifier</code>.</p> <p>Modifiers for specific subcomponents should be named <code>xModifier</code> (e.g., <code>headerModifier</code> for a header subcomponent) and follow the same default value guidelines.</p> <p>More info: Modifier documentation</p> <p> compose:modifier-naming ktlint  ModifierNaming detekt</p>"},{"location":"rules/#avoid-modifier-extension-factory-functions","title":"Avoid Modifier extension factory functions","text":"<p>The <code>composed {}</code> API for creating custom modifiers is no longer recommended due to performance issues. Use <code>Modifier.Node</code> instead.</p> <p>More info: Modifier.Node, Compose Modifier.Node and where to find it, by Merab Tato Kutalia, Compose modifiers deep dive, with Leland Richardson and Composed modifier docs.</p> <p> compose:modifier-composed-check ktlint  ModifierComposed detekt</p>"},{"location":"rules/#componentdefaults","title":"ComponentDefaults","text":""},{"location":"rules/#componentdefaults-object-should-match-the-composable-visibility","title":"ComponentDefaults object should match the composable visibility","text":"<p>If your composable has an associated <code>Defaults</code> object, it should have the same visibility as the composable. This lets consumers build upon the original defaults instead of copy-pasting them.</p> <p>More info: Compose Component API Guidelines</p> <p> compose:defaults-visibility ktlint  DefaultsVisibility detekt</p>"},{"location":"rules/#opt-in-rules","title":"Opt-in rules","text":"<p>These rules are disabled by default</p> <p>You'll need to explicitly enable them individually in your project's detekt/ktlint configuration.</p>"},{"location":"rules/#dont-use-material-2","title":"Don't use Material 2","text":"<p>Material Design 3 supersedes Material 2, offering updated theming, components, and Material You personalization features like dynamic color. Use Material 3 for new projects.</p> <p>Enabling: ktlint, detekt</p> <p>More info: Migration to Material 3</p> <p> compose:material-two ktlint  Material2 detekt</p>"},{"location":"rules/#avoid-using-unstable-collections","title":"Avoid using unstable collections","text":"<p>Did you know?</p> <p>You can add the kotlin collections to your stability configuration (<code>kotlin.collections.*</code>) to make this rule unnecessary.</p> <p>Kotlin collection interfaces (<code>List&lt;T&gt;</code>, <code>Map&lt;T&gt;</code>, <code>Set&lt;T&gt;</code>) can't guarantee immutability. For example:</p> <pre><code>// \u274c The compiler won't be able to infer that the list is immutable\nval list: List&lt;String&gt; = mutableListOf()\n</code></pre> <p>The variable is constant and the declared type is immutable, but the implementation is mutable. The Compose compiler only sees the declared type and marks it as unstable.</p> <p>To make the compiler treat a collection as immutable, you have two options:</p> <p>You can use Kotlinx Immutable Collections:</p> <pre><code>// \u2705 The compiler knows that this list is immutable\nval list: ImmutableList&lt;String&gt; = persistentListOf&lt;String&gt;()\n</code></pre> <p>Alternatively, wrap your collection in a stable class:</p> <pre><code>// \u2705 The compiler knows that this class is immutable\n@Immutable\ndata class StringList(val items: List&lt;String&gt;)\n// ...\nval list: StringList = StringList(yourList)\n</code></pre> <p>Note: Kotlinx Immutable Collections is preferred. The wrapper approach only promises immutability via annotation while the underlying <code>List</code> remains mutable.</p> <p>More info: Jetpack Compose Stability Explained, Kotlinx Immutable Collections</p> <p> compose:unstable-collections ktlint  UnstableCollections detekt</p>"},{"location":"rules/#naming-previews-properly","title":"Naming previews properly","text":"<p>Configure the naming strategy for previews to match your project's conventions.</p> <p>By default, this rule requires <code>Preview</code> as a suffix. You can change this via the <code>previewNamingStrategy</code> property:</p> <ul> <li><code>suffix</code>: Previews should have <code>Preview</code> as suffix.</li> <li><code>prefix</code>: Previews should have <code>Preview</code> as prefix.</li> <li><code>anywhere</code>: Previews should contain <code>Preview</code> in their names.</li> </ul> <p> compose:preview-naming ktlint  PreviewNaming detekt</p>"}]}